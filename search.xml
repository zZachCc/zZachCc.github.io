<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>NAC-802.1/MAC/Portal</title>
    <url>/2022/07/23/NAC-802-1-MAC-Portal/</url>
    <content><![CDATA[<h1 id="1-NAC"><a href="#1-NAC" class="headerlink" title="1. NAC"></a>1. NAC</h1><p><strong>什么是NAC？</strong></p>
<blockquote>
<p>NAC（Network Access Control）称为<strong>网络接入控制</strong>，通过对接入网络的客户端和用户的认证保证网络的安全，是一种“端到端”的安全技术。</p>
</blockquote>
<p><strong>NAC场景的基本结构</strong></p>
<blockquote>
<p>终端(接入者) —– NAS(接入设备.eg. switch/AP) —– AAA服务器</p>
</blockquote>
<p><strong>NAC和AAA是什么关系？</strong></p>
<table>
<thead>
<tr>
<th align="left">NAC</th>
<th align="left">AAA</th>
</tr>
</thead>
<tbody><tr>
<td align="left">用于终端和接入设备之间的交互</td>
<td align="left">用于接入设备与认证服务器之间的交互</td>
</tr>
<tr>
<td align="left">终端通过NAC机制传递用户名/密码给接入设备</td>
<td align="left">接入设备通过AAA来认证用户</td>
</tr>
</tbody></table>
<blockquote>
<p>Cc白话：NAC用来收集终端用户的信息，AAA用来认证、授权这个用户</p>
</blockquote>
<p><strong>NAC的三种方式</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>对比项</strong></th>
<th align="left"><strong>802.1X认证</strong></th>
<th align="left"><strong>MAC认证</strong></th>
<th align="left"><strong>Portal认证</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><div style="width: 50pt">终端需求</div></td>
<td align="left">终端需安装客户端</td>
<td align="left">终端无需安装客户端</td>
<td align="left">终端无需安装客户端</td>
</tr>
<tr>
<td align="left">适用场景</td>
<td align="left">新建网络、用户固定、信息安全要求严格的场景</td>
<td align="left">哑终端(打印机、IP电话等)需要接入认证的场景</td>
<td align="left">用户分散、用户流动性大的场景</td>
</tr>
</tbody></table>
<hr>
<h1 id="2-802-1X认证"><a href="#2-802-1X认证" class="headerlink" title="2. 802.1X认证"></a>2. 802.1X认证</h1><h2 id="2-1-802-1X认证简介"><a href="#2-1-802-1X认证简介" class="headerlink" title="2.1 802.1X认证简介"></a>2.1 802.1X认证简介</h2><p><strong>定义</strong></p>
<blockquote>
<p>802.1X协议是一种“基于端口的网络接入控制协议”，所以802.1X是在“接口”上配置生效的(物理接口/虚拟接口)</p>
</blockquote>
<p><strong>802.1X认证场景的基本结构</strong></p>
<blockquote>
<p>和基本NAC的场景结构一致: 客户端/接入设备/认证服务器<br><img src="/2022/07/23/NAC-802-1-MAC-Portal/image-220220724205635.png" alt="image1"></p>
<ul>
<li>客户端：是指终端设备上的支持的802.1X软件，用户可以通过启动客户端软件发起802.1X认证</li>
<li>接入设备：通常为支持802.1X协议的网络设备，它为客户端提供接入局域网的端口，该端口可以是物理端口，也可以是逻辑端口</li>
<li>认证服务器：用于实现对用户进行认证、授权和计费，通常为RADIUS服务器</li>
</ul>
</blockquote>
<hr>
<h2 id="2-2-802-1X认证所需的协议"><a href="#2-2-802-1X认证所需的协议" class="headerlink" title="2.2 802.1X认证所需的协议"></a>2.2 802.1X认证所需的协议</h2><p>802.1X认证需要在客户端与接入设备之间交互用户的信息，这些信息是通过什么协议交互的？</p>
<blockquote>
<p>EAP (Extensible Authentication Protocol)</p>
</blockquote>
<p>EAP早期是为PPP协议设计的一款协议，无法在Ethernet上传输，怎么办？</p>
<blockquote>
<p>EAPoL(EAP over LANs)， 在EAP报文外面再封装一层EAPoL，EAPoL外面直接封装Ethernet帧头，不需要封装IP协议，因为802.1X协议是一个纯二层协议</p>
</blockquote>
<h3 id="2-2-1-EAP报文结构"><a href="#2-2-1-EAP报文结构" class="headerlink" title="2.2.1 EAP报文结构"></a>2.2.1 EAP报文结构</h3><p><img src="/2022/07/23/NAC-802-1-MAC-Portal/image-220220724210811.png" alt="image2"></p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Code</td>
<td align="left">表示EAP数据包的类型: <br> 1:Request <br> 2:Response <br> 3:Success <br> 4:Failure</td>
</tr>
<tr>
<td align="left">ID</td>
<td align="left">用于对应一个Request和它的Response</td>
</tr>
<tr>
<td align="left">Length</td>
<td align="left">表示EAP数据包的长度，包括Code、ID、Length以及Data各字段的总长度</td>
</tr>
<tr>
<td align="left">Data</td>
<td align="left">Data字段的格式由Code的值来决定<br>- 当Code字段为1或2时，EAP为Request和Response报文，Data包含Type, Type Data两个字段。Type表示Request/Response的类型；Type Data为类型所包含的内容<br>- 当Code取值为3或者4时，EAP为Success和Failure报文，没有Data字段。</td>
</tr>
</tbody></table>
<p>Code为1时，报文类型是EAP-Request；Code为2时，报文类型是EAP-Response。这两类<br>报文是有负载的，也就是Data字段，Data字段中的内容如下：</p>
<table>
<thead>
<tr>
<th align="left">Type字段值</th>
<th align="left">类型</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><div style="width: 50pt">1</div></td>
<td align="left"><div style="width: 60pt">Identity</div></td>
<td align="left"><div style="width: 300pt">携带用户的用户名信息</div></td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Notification</td>
<td align="left">非必须的通知消息，传送一些警告消息，例如密码已过期、账号被锁等。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">NAK</td>
<td align="left">仅用于Response帧，表示否定确认。例如终端使用了接入设备不支持的认证方法发起请求，客户端可利用Response/NAK报文以告知终端其支持的认证方法</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">MD5-Challenge</td>
<td align="left">携带用户的密码信息(MD5哈希加密)</td>
</tr>
</tbody></table>
<h3 id="2-2-2-EAPoL"><a href="#2-2-2-EAPoL" class="headerlink" title="2.2.2 EAPoL"></a>2.2.2 EAPoL</h3><p>EAPoL是802.1X协议定义的一种报文封装格式，使EAP可以在LAN上进行传输。</p>
<p><img src="/2022/07/23/NAC-802-1-MAC-Portal/image-220220724214829.png" alt="image3"></p>
<table>
<thead>
<tr>
<th align="left">字段</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">PAE Ethernet Type</td>
<td align="left">表示协议类型，值为0x888E。</td>
</tr>
<tr>
<td align="left">Protocol Version</td>
<td align="left">表示EAPoL帧的发送方所支持的802.1X协议版本号</td>
</tr>
<tr>
<td align="left">Type</td>
<td align="left">表示EAPoL数据帧类型:<br>00：EAP-Packet，用于封装EAP报文(EAP在负载里面)<br>01：EAPoL-Start，用于用户主动发起认证过程<br>02：EAPoL-Logoff，用于用户主动发起下线请求<br>03：EAPoL-Key，密钥信息报文。</td>
</tr>
<tr>
<td align="left">Length</td>
<td align="left">表示负载的长度，也就是Packet Body字段的长度，EAPoL-Start和EAPoL-Logoff报文的Length值都为0</td>
</tr>
<tr>
<td align="left">Packet Body</td>
<td align="left">当EAPoL type为00时，EAP报文就封装在这里</td>
</tr>
</tbody></table>
<h2 id="2-3-802-1X认证流程"><a href="#2-3-802-1X认证流程" class="headerlink" title="2.3 802.1X认证流程"></a>2.3 802.1X认证流程</h2><p><strong>802.1X怎么触发？</strong></p>
<blockquote>
<p>802.1X认证有以下触发方式：</p>
<ul>
<li>  终端主动发送EAPoL-Start报文给接入设备，触发认证。</li>
<li>  终端关联至接入设备时，接入设备触发认证。(唯一的差别就是，没有下述流程中的第一步)</li>
</ul>
</blockquote>
<p><strong>802.1X认证方式</strong></p>
<blockquote>
<p><strong>1. 中继方式</strong></p>
<ul>
<li>中继方式中，接入设备将EAP-Response/Identity和EAP-Response/MD5Challenge这两个报文直接通过Radius的Access-Request报文透传给Radius服务器</li>
<li>Radius服务器以EAP的方式验证用户信息</li>
</ul>
</blockquote>
<blockquote>
<p><strong>2. 终结方式</strong></p>
<ul>
<li>终结方式中，接入设备将EAP-Response/Identity和EAP-Response/MD5Challenge这两个报文中的用户信息提取出来，再用Radius报文把用户信息封装到Access-Request报文发送给Radius服务器</li>
<li>Radius服务器以PAP或CHAP的方式验证用户信息</li>
</ul>
</blockquote>
<p><strong>802.1X认证流程</strong></p>
<blockquote>
<p><strong>EAP中继方式</strong><br><img src="/2022/07/23/NAC-802-1-MAC-Portal/image-220220724223847.png" alt="image4"><br>(1) 终端向接人设备发送一个EAPoL-Start报文，开始802.1x认证接入；<br>(2) 接入设备向终端发送EAP-Request/Identity 报文，要求客户端将用户名发过来；<br>(3) 终端回应一个EAP-Response/Identity 给接入设备，其中包括用户名；<br>(4) 接入设备将EAP-Response/Identity 报文封装到RADIUS的Access-Request 报文中，发送给认证服务器；<br>(5) 认证服务器产生一个EAP-Request/MD5-Challenge报文，封装到RADIUS的Access-Challenge 报文中，发送给接入设备；<br>(6) 接入设备拆掉Radius封装，把EAP-Request/MD5-Challenge 发送给终端，要求终端进行认证；<br>(7) 终端收到EAP-Request/MD5-Challenge报文后，对“用户密码+Challenge”做MD5算法生成Challenged-Password，将Challenged-Password封装到EAP-Response/MD5-Challenge 回应给接入设备；<br>(8) 接入设备将EAP-Response/MD5-Challenge封装到Radius的Access-Request 报文中，发送给认证服务器；<br>(9) 认证服务器现在拥有了终端的用户名以及密码，采用EAP的方式认证用户；<br>(10) 认证服务器生成EAP-Success报文，封装到Radius的Access-Accept 报文中，发送给接入设备；<br>(11) 接入设备拆掉Radius封装，把EAP-Success报文发送给终端，并将端口改为授权状态。<br>(12) 终端可以发送EAPoL-Logoff报文给接入设备，主动要求下线；<br>(13) 接入设备把端口状态从授权状态改变成未授权状态，并向客户端发送EAP-Failure报文。</p>
</blockquote>
<blockquote>
<p><strong>EAP终结方式</strong><br><img src="/2022/07/23/NAC-802-1-MAC-Portal/image-220220724224025.png" alt="image6"><br>(1) 终端向接人设备发送一个EAPoL-Start报文，开始802.1x认证接入；<br>(2) 接入设备向终端发送EAP-Request/Identity 报文，要求客户端将用户名发过来；<br>(3) 终端回应一个EAP-Response/Identity 给接入设备，其中包括用户名；<br>(4) 接入设备产生一个EAP-Request/MD5-Challenge报文，发送给终端；<br>(5) 终端收到EAP-Request/MD5-Challenge报文后，对“用户密码+Challenge”做MD5算法生成Challenged-Password，将Challenged-Password封装到EAP-Response/MD5-Challenge 回应给接入设备；<br>(6) 接入设备提取出用户名和密码，将其封装到Radius的Access-Request 报文中(PAP或CHAP方式)，发送给认证服务器；<br>(7) 认证服务器现在拥有了终端的用户名以及密码，采用PAP或CHAP的方式认证用户，如成功，认证服务器生成EAP-Success报文，封装到Radius的Access-Accept 报文中，发送给接入设备；<br>(8) 接入设备拆掉Radius封装，把EAP-Success报文发送给终端，并将端口改为授权状态。<br>(9) 终端可以发送EAPoL-Logoff报文给接入设备，主动要求下线；<br>(10) 接入设备把端口状态从授权状态改变成未授权状态，并向客户端发送EAP-Failure报文。</p>
</blockquote>
<hr>
<h1 id="3-MAC认证"><a href="#3-MAC认证" class="headerlink" title="3. MAC认证"></a>3. MAC认证</h1><h2 id="3-1-MAC认证简介"><a href="#3-1-MAC认证简介" class="headerlink" title="3.1 MAC认证简介"></a>3.1 MAC认证简介</h2><p><strong>定义</strong><br>MAC认证，全称MAC地址认证，是一种基于接口的认证方式，基于终端MAC地址对用户的访问权限进行控制。</p>
<p><strong>特点</strong></p>
<ul>
<li>  用户终端不需要安装任何客户端软件。</li>
<li>  MAC认证过程中，不需要用户手动输入用户名和密码。</li>
<li>  能够对不具备802.1X认证能力的终端进行认证，如打印机和传真机等哑终端。</li>
</ul>
<p><strong>认证系统</strong><br>MAC认证系统为典型的客户端/服务器结构，包括三个实体：终端、接入设备和认证服务器<br><img src="/2022/07/23/NAC-802-1-MAC-Portal/image-20220831175958.png" alt="image12"></p>
<blockquote>
<ul>
<li>终端：尝试接入网络的终端设备。</li>
<li>接入设备：是终端访问网络的其中一个网络节点，在这个设备上启用MAC认证。</li>
<li>认证服务器：用于实现对用户进行认证、授权，通常为RADIUS服务器。</li>
</ul>
</blockquote>
<hr>
<h2 id="3-2-MAC认证流程"><a href="#3-2-MAC认证流程" class="headerlink" title="3.2 MAC认证流程"></a>3.2 MAC认证流程</h2><blockquote>
<p><strong>终端-接入设备</strong><br>不需要专门的协议承载(比如802.1x需要EAP协议承载请求报文)，接入设备收到终端发送的arp/dhcp/dhcpv6/nd报文，就可以触发MAC认证</p>
<p><strong>接入设备-认证服务器</strong><br>接入设备与认证服务器之间的认证过程使用Radius协议承载<br>MAC认证可以使用的Radius用户认证机制有两种：PAP/CHAP</p>
</blockquote>
<p><strong>MAC认证流程(PAP机制)</strong><br><img src="/2022/07/23/NAC-802-1-MAC-Portal/image-20220831181630.png" alt="image11"></p>
<p>(1) 接入设备收到终端发送的arp/dhcp/dhcpv6/nd报文，触发MAC认证。<br>(2) PAP机制中，接入设备将认证用户的<strong>共享密钥、自己生成的随机值</strong>依次排列后经过MD5算法进行HASH处理；然后将<strong>用户名、HASH处理结果以及随机值</strong>封装在RADIUS认证请求报文中发送给RADIUS服务器，请求RADIUS服务器对该终端进行身份认证。<br>(3) RADIUS服务器使用本地数据库中对应认证用户的信息进行认证，认证成功则发送认证接受报文，认证失败则发送认证失败报文。</p>
<p><strong>MAC认证流程(CHAP机制)</strong><br>(1) 接入设备收到终端发送的arp/dhcp/dhcpv6/nd报文，触发MAC认证。<br>(2) PAP机制中，接入设备发起一个ChallengeID请求给Radius服务器<br>(3) Radius服务回复一个MD5-Challenge发送给接入设备<br>(4) 接入设备将认证用户的<strong>共享密钥、自己生成的随机值、ChallengeID</strong>次排列后经过MD5算法进行HASH处理；然后将<strong>用户名、HASH处理结果以及随机值</strong>封装在RADIUS认证请求报文中发送给RADIUS服务器，请求RADIUS服务器对该终端进行身份认证。<br>(5) RADIUS服务器使用本地数据库中对应认证用户的信息进行认证，认证成功则发送认证接受报文，认证失败则发送认证失败报文。</p>
<blockquote>
<p><strong>CcNotes：</strong><br>可以看到MAC认证的时候也需要用户名和密码来进行Radius认证，那MAC认证的用户名和密码是什么呢？</p>
<table>
<thead>
<tr>
<th align="left">MAC认证用户名</th>
<th align="left">MAC认证密码</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><div style="width: 80pt"> 终端的MAC地址</div></td>
<td align="left"><div style="width: 120pt">终端的MAC地址 or 指定的密码</div></td>
<td align="left">客户端少量部署且MAC地址容易获取的场景</td>
</tr>
<tr>
<td align="left">指定的用户名</td>
<td align="left">指定的密码</td>
<td align="left">当同一个接口下可以存在多个终端，可以在这个接口配置一套MAC认证的用户名密码，此时所有终端均使用指定的用户名和密码进行MAC认证，服务器端仅需要配置一个账户即可满足这个接口下所有终端的MAC认证需求</td>
</tr>
</tbody></table>
</blockquote>
<h1 id="4-Portal认证"><a href="#4-Portal认证" class="headerlink" title="4. Portal认证"></a>4. Portal认证</h1><h2 id="4-1-Portal认证简介"><a href="#4-1-Portal认证简介" class="headerlink" title="4.1 Portal认证简介"></a>4.1 Portal认证简介</h2><p><strong>定义</strong><br>Portal认证通常也称为Web认证，一般将Portal认证网站称为门户网站。<br>用户上网时，必须在门户网站进行认证，如果未认证成功，仅可以访问特定的网络资源，认证成功后，才可以访问其他网络资源。</p>
<p><strong>特点</strong></p>
<ul>
<li>  一般情况下不需要安装额外的软件客户端，通过浏览器直接在Web页面上认证，简单方便。</li>
<li>  便于运营，可以在Portal页面上进行业务拓展，如广告推送、企业宣传等。</li>
<li>  部署位置灵活，可以在”接入层设备”或”关键数据的入口设备”上做访问控制。</li>
<li>  用户管理灵活，可基于”用户名”与”VLAN/IP地址/MAC地址”的组合对用户进行认证。</li>
</ul>
<p><strong>认证系统</strong><br>Portal认证系统，主要包括四个基本要素：客户端、接入设备、Portal服务器与认证服务器。<br><img src="/2022/07/23/NAC-802-1-MAC-Portal/image-20220831105823.png" alt="image7"></p>
<blockquote>
<ul>
<li>客户端：安装有运行HTTP/HTTPS协议的浏览器的主机。</li>
<li>接入设备：交换机、路由器等接入设备的统称，主要有三方面的作用：<ul>
<li>在认证之前，将认证网段内用户的所有HTTP/HTTPS请求都重定向到Portal服务器。</li>
<li>在认证过程中，与Portal服务器、认证服务器交互，完成对用户身份认证、授权与计费的功能。</li>
<li>在认证通过后，允许用户访问被管理员授权的网络资源。</li>
</ul>
</li>
<li>Portal服务器：接收客户端认证请求的服务器系统，提供免费门户服务和认证界面，<strong>与接入设备交互客户端的认证信息</strong>。</li>
<li>认证服务器：<strong>与接入设备进行交互，完成对用户的认证、授权与计费</strong>。</li>
</ul>
</blockquote>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Ccnotes:</span><br><span class="line">Portal服务器可以是</span><br><span class="line">1. 接入设备之外的独立实体（外置Portal服务器）</span><br><span class="line">2. 也可以是存在于接入设备之内的内嵌实体（内置Portal服务器）</span><br><span class="line"></span><br><span class="line">内置Portal服务器的接入设备实现了简单的Portal服务器功能，仅能给用户提供通过Web方式上线、下线的基本功能，并不能完全替代独立的Portal服务器，也不支持外置独立服务器的任何扩展功能（例如不支持MAC优先的Portal认证）。</span><br><span class="line">通过内置Portal服务器进行Portal认证，由于不需要部署额外的Portal服务器，故增强了Portal认证的通用性。但是，受限于接入设备存储空间、功能和性能，内置Portal服务器适用于功能简单、接入人数少的场景，例如小型餐馆提供的连接Internet服务。</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="4-2-Portal协议格式"><a href="#4-2-Portal协议格式" class="headerlink" title="4.2 Portal协议格式"></a>4.2 Portal协议格式</h2><p>Portal协议报文由固定长度头和可变长度的Attribute字段组成，Attribute字段采用TLV（Type-Length-Value）格式<br><img src="/2022/07/23/NAC-802-1-MAC-Portal/image-20220831121338.png" alt="image8"><br><strong>Type字段</strong><br>Type字段定义了Portal报文的类型，长度为1字节，常用的Portal报文类型如下</p>
<table>
<thead>
<tr>
<th align="left">报文类型</th>
<th align="left">取值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">REQ_CHALLENGE</td>
<td align="left">0x01</td>
<td align="left">Portal服务器向接入设备发送的Challenge请求报文</td>
</tr>
<tr>
<td align="left">ACK_CHALLENGE</td>
<td align="left">0x02</td>
<td align="left">接入设备对Portal服务器Challenge请求的响应报文</td>
</tr>
<tr>
<td align="left">REQ_AUTH</td>
<td align="left">0x03</td>
<td align="left">Portal服务器向接入设备发送的认证请求报文</td>
</tr>
<tr>
<td align="left">ACK_AUTH</td>
<td align="left">0x04</td>
<td align="left">接入设备对Portal服务器认证请求的响应报文</td>
</tr>
<tr>
<td align="left">AFF_ACK_AUTH</td>
<td align="left">0x07</td>
<td align="left">Portal服务器向接入设备发送的认证成功响应报文</td>
</tr>
</tbody></table>
<p><strong>Attribute字段</strong><br>一个可变长字段，由多个属性组合而成，每个属性的格式为Type/Length/Value格式</p>
<table>
<thead>
<tr>
<th align="left">Attribute名</th>
<th align="left">AttrType</th>
<th align="left">AttrLen</th>
<th align="left">AttrValue</th>
<th align="left">使用该属性的报文</th>
</tr>
</thead>
<tbody><tr>
<td align="left">UserName</td>
<td align="left">0x01</td>
<td align="left">1～253</td>
<td align="left">用户名</td>
<td align="left">REQ_AUTH</td>
</tr>
<tr>
<td align="left">PassWord</td>
<td align="left">0x02</td>
<td align="left">1～128</td>
<td align="left">用户密码</td>
<td align="left">REQ_AUTH</td>
</tr>
<tr>
<td align="left">Challenge</td>
<td align="left">0x03</td>
<td align="left">16</td>
<td align="left">CHAP方式加密的认证字</td>
<td align="left">ACK_CHALLENGE</td>
</tr>
<tr>
<td align="left">ChapPassWord</td>
<td align="left">0x04</td>
<td align="left">16</td>
<td align="left">经过CHAP方式加密后的密码</td>
<td align="left">REQ_AUTH</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-3-Portal认证流程"><a href="#4-3-Portal认证流程" class="headerlink" title="4.3 Portal认证流程"></a>4.3 Portal认证流程</h2><h3 id="4-3-1-基于Portal协议的Portal认证流程"><a href="#4-3-1-基于Portal协议的Portal认证流程" class="headerlink" title="4.3.1 基于Portal协议的Portal认证流程"></a>4.3.1 基于Portal协议的Portal认证流程</h3><p><img src="/2022/07/23/NAC-802-1-MAC-Portal/image-20220831113753.png" alt="image9"></p>
<p>(1) 在Portal认证之前，客户端可与接入设备之间建立起预连接，但只有部分网络访问权限。</p>
<p>(2) 客户端发起HTTP连接请求。</p>
<p>(3) 接入设备将HTTP请求中的URL地址重定向到Portal服务器，返回给客户端。</p>
<p>(4) 客户端根据获得的URL地址，向Portal服务器发起HTTP连接请求(HTTP Request1)。</p>
<p>(5) Portal服务器向客户端返回Portal认证页面(HTTP Response1)。</p>
<p>(6) 用户在Portal认证页面输入用户名和密码后，客户端向Portal服务器发起Portal认证请求(HTTP Request2)。<br><strong>认证阶段开始-基于Portal协议</strong></p>
<p>(7) (可选) Portal服务器收到Portal认证请求后，如果Portal服务器与接入设备之间采用CHAP认证，则Portal服务器向接入设备发起Portal挑战字请求报文(REQ_CHALLENGE)(Portal Request1)；如果Portal服务器与接入设备之间采用PAP认证，则没有第7.8步。</p>
<p>(8) (可选)接入设备向Portal服务器回应Portal挑战字应答报文(ACK_CHALLENGE)(Portal Response1)。</p>
<p>(9) Portal服务器将用户输入的用户名和密码封装在Portal认证请求报文(REQ_AUTH)(Portal Request2)中，发送给接入设备。</p>
<p>(10) 接入设备根据获取到的用户名和密码，向RADIUS服务器发送RADIUS认证请求(ACCESS-REQUEST)(Radius Request1)。</p>
<p>(11) RADIUS服务器对用户名和密码进行认证。如果认证成功，则RADIUS服务器向接入设备发送认证接受报文(ACCESS-ACCEPT)(Radius Response1)；如果认证失败，则RADIUS服务器返回认证拒绝报文(ACCESS-REJECT)。</p>
<p>(12) 接入设备根据接收到的认证结果接入/拒绝用户。如果允许用户接入，则接入设备向RADIUS服务器发送计费开始请求报文(ACCOUNTING-REQUEST)(Radius Request2)。</p>
<p>(13) RADIUS服务器返回计费开始响应报文(ACCOUNTING-RESPONSE)(Radius Response2)，并开始计费。</p>
<p>(14) 接入设备向Portal服务器返回Portal认证结果(ACK_AUTH)(Portal Response2)，并将用户加入自身在线用户列表。<br><strong>认证阶段结束-基于Portal协议</strong></p>
<p>(15) Portal服务器向客户端发送认证结果报文(HTTP Response2)，通知客户端认证成功，并将用户加入自身在线用户列表。</p>
<p>(16) Portal服务器向接入设备发送认证应答确认(AFF_ACK_AUTH)(对Portal Response2的确认)</p>
<h3 id="4-3-2-基于HTTP-HTTPS协议的Portal认证流程"><a href="#4-3-2-基于HTTP-HTTPS协议的Portal认证流程" class="headerlink" title="4.3.2 基于HTTP/HTTPS协议的Portal认证流程"></a>4.3.2 基于HTTP/HTTPS协议的Portal认证流程</h3><p><img src="/2022/07/23/NAC-802-1-MAC-Portal/image-20220831115955.png" alt="image6"></p>
<p>(1) 在Portal认证之前，客户端可与接入设备之间建立起预连接，但只有部分网络访问权限。</p>
<p>(2) 客户端发起HTTP连接请求。</p>
<p>(3) 接入设备将HTTP请求中的URL地址重定向到Portal服务器，返回给客户端。</p>
<p>(4) 客户端根据获得的URL地址，向Portal服务器发起HTTP连接请求(HTTP Request1)。</p>
<p>(5) Portal服务器向客户端返回Portal认证页面(HTTP Response1)。</p>
<p>(6) 用户在Portal认证页面输入用户名和密码后，客户端向Portal服务器发起Portal认证请求(HTTP Request2)。</p>
<p>(7) Portal服务器通知客户端向接入设备发起Portal认证请求(HTTP Response2)。<br><strong>认证阶段开始-基于HTTP协议</strong></p>
<p>(8) 客户端向接入设备发起Portal认证请求(HTTP POST/GET)(HTTP Request3)。</p>
<p>(9) 接入设备根据获取到的用户名和密码，向RADIUS服务器发送RADIUS认证请求(ACCESS-REQUEST)(Radius Request1)。</p>
<p>(10) RADIUS服务器对用户名和密码进行认证。如果认证成功，则RADIUS服务器向接入设备发送认证接受报文(ACCESS-ACCEPT)(Radius Response1)；如果认证失败，则RADIUS服务器返回认证拒绝报文(ACCESS-REJECT)。</p>
<p>(11) 接入设备根据接收到的认证结果接入/拒绝用户。如果允许用户接入，则接入设备向RADIUS服务器发送计费开始请求报文(ACCOUNTING-REQUEST)(Radius Request2)。</p>
<p>(12) RADIUS服务器返回计费开始响应报文(ACCOUNTING-RESPONSE)(Radius Response2)，并开始计费。</p>
<p>(13) 接入设备向客户端返回Portal认证结果(HTTP Response3)，并将用户加入自身在线用户列表。<br><strong>认证阶段-基于HTTP协议</strong></p>
<hr>
<h1 id="5-MAC优先的Portal认证"><a href="#5-MAC优先的Portal认证" class="headerlink" title="5 MAC优先的Portal认证"></a>5 MAC优先的Portal认证</h1><h2 id="5-1-MAC优先的Portal认证定义"><a href="#5-1-MAC优先的Portal认证定义" class="headerlink" title="5.1 MAC优先的Portal认证定义"></a>5.1 MAC优先的Portal认证定义</h2><ul>
<li>MAC优先的Portal认证是指用户进行Portal认证成功后，在一定时间内断开网络重新连接，能够直接通过MAC认证接入，无需输入用户名密码重新进行Portal认证。</li>
<li>该功能需要在设备配置MAC+Portal的混合认证，同时在Raidus服务器上开启”Portal认证成功自动注册MAC认证信息“功能并配置MAC地址有效时间。</li>
<li>用户Portal认证成功后，在MAC地址有效时间内，可以通过MAC认证重新接入网络。</li>
</ul>
<h2 id="5-2-认证流程"><a href="#5-2-认证流程" class="headerlink" title="5.2 认证流程"></a>5.2 认证流程</h2><p><img src="/2022/07/23/NAC-802-1-MAC-Portal/image-20220831185938.png" alt="image13"></p>
<p>(1) 客户端用户首次认证时，接入设备会把客户端的MAC地址发到RADIUS服务器进行认证，但由于RADIUS服务器未查找到MAC地址信息，导致认证失败，触发客户端用户进行Portal认证。<br>(2) Portal认证成功后，RADIUS服务器会自动保存客户端的MAC地址。<br>(3) 当客户端离线后重新尝试接入网络时，接入设备会把客户端的MAC地址发到RADIUS服务器进行认证。</p>
<ul>
<li>  如果客户端的MAC地址还保存在RADIUS服务器，则RADIUS服务器校验用户名和密码（用户名和密码均为MAC地址）后，直接进行授权，用户授权后即可以直接访问网络，不需要再次进行Portal认证。</li>
<li>如果客户端的MAC地址在RADIUS服务器已经过期，则MAC认证失败，并且RADIUS服务器会删除保存的客户端MAC地址。MAC地址认证失败之后，接入设备会向客户端用户推送Portal认证页面。客户端用户输入帐号和密码进行Portal认证。</li>
</ul>
]]></content>
      <categories>
        <category>Networking</category>
      </categories>
  </entry>
  <entry>
    <title>AAA之Radius</title>
    <url>/2022/07/23/AAA%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="1-AAA"><a href="#1-AAA" class="headerlink" title="1. AAA"></a>1. AAA</h1><h2 id="1-1-什么是AAA？"><a href="#1-1-什么是AAA？" class="headerlink" title="1.1  什么是AAA？"></a>1.1  什么是AAA？</h2><p>AAA是Authentication(认证), Authorization(授权), Accounting(计费)的简称</p>
<p>AAA是一种框架，AAA可以==通过多种协议来实现==最常使用RADIUS（Remote Authentication Dial-In User Service）远程认证拨号用户服务</p>
<h2 id="1-2-AAA的流程"><a href="#1-2-AAA的流程" class="headerlink" title="1.2 AAA的流程"></a>1.2 AAA的流程</h2><p><img src="/2022/07/23/AAA%E6%A6%82%E8%BF%B0/image-20220704172506.png" alt="Pasted image 20220704172506"></p>
<h2 id="1-3-AAA的应用场景"><a href="#1-3-AAA的应用场景" class="headerlink" title="1.3 AAA的应用场景"></a>1.3 AAA的应用场景</h2><ol>
<li> 网络运营商（ISP），需要验证家庭宽带用户的账号密码之后才允许其上网（认证/授权），并记录用户的上网时长/上网流量（计费）</li>
<li> WiFi业务随行，不管用户连接到哪个SSID，都对同一用户提供相同的对待，而对不同用户进行区分对待</li>
<li> 需要认证用户身份的场景（比如VPN）</li>
</ol>
<h2 id="1-4-AAA的组件架构"><a href="#1-4-AAA的组件架构" class="headerlink" title="1.4 AAA的组件架构"></a>1.4 AAA的组件架构</h2><p><img src="/2022/07/23/AAA%E6%A6%82%E8%BF%B0/image-20220704172726.png" alt="image1"></p>
<blockquote>
<p><strong>终端用户(User)</strong><br>其实在AAA中，没有User参与，User通过NAC机制传递用户名/密码给NAS</p>
</blockquote>
<blockquote>
<p><strong>NAS(Network Access Server)(AAA客户端)</strong></p>
<ul>
<li>负责集中收集和管理用户的NAC访问请求</li>
<li>再将用户信息到通过AAA协议传递到指定的AAA服务器</li>
<li>NAS一般为网络设备(接入交换机, AP都可以作为NAS)</li>
</ul>
</blockquote>
<blockquote>
<p><strong>AAA server</strong></p>
<ul>
<li>支持Radius协议(开源协议)的AAA Server有：WinRadius, FreeRadius, SAM</li>
<li>支持TACAS协议(Cisco私有)的AAA Server有：Cisco ACS(Access Control Server)</li>
</ul>
</blockquote>
<hr>
<h1 id="2-Radius"><a href="#2-Radius" class="headerlink" title="2. Radius"></a>2. Radius</h1><h2 id="2-1-RADIUS概述"><a href="#2-1-RADIUS概述" class="headerlink" title="2.1 RADIUS概述"></a>2.1 RADIUS概述</h2><ul>
<li>AAA可以共过多种协议来实现，最常使用的就是RADIUS协议(Remote  Authentication Dial In User Service) (远程用户拨号认证)</li>
<li>该协议可以为Authentication, Authorization, Accounting提供协议层面的完整支持 (相比LDAP就支持不了Accounting)</li>
<li>该协议基于UDP协议，并规定了目的UDP Port 1812为认证授权端口，1813为计费端口</li>
</ul>
<h2 id="2-2-RADIUS中的组件"><a href="#2-2-RADIUS中的组件" class="headerlink" title="2.2 RADIUS中的组件"></a>2.2 RADIUS中的组件</h2><blockquote>
<p><strong>RADIUS客户端</strong><br>一般位于网络接入服务器NAS（Network Access Server）上，可以遍布整个网络，负责传输用户信息到指定的RADIUS服务器，然后根据从服务器返回的信息进行相应处理（如接受/拒绝用户接入)</p>
</blockquote>
<blockquote>
<p><strong>RADIUS服务器</strong></p>
<ul>
<li>一般运行在中心计算机或工作站上，维护相关的用户认证和授权信息</li>
<li>负责接收用户连接请求并认证用户</li>
<li>然后给客户端返回所有需要的信息（如接受/拒绝认证请求）</li>
</ul>
<p>RADIUS服务器通常要维护<strong>三个数据库</strong><br><img src="/2022/07/23/AAA%E6%A6%82%E8%BF%B0/image-20220704144053.png" alt="image3"></p>
<ul>
<li>Users：用于存储用户信息（如用户名、密码以及使用的协议、IP地址等配置信息）。</li>
<li>  Clients：用于存储RADIUS客户端的信息（如共享密钥、IP地址等）。</li>
<li>  Dictionary：用于存储RADIUS协议中的属性和属性值含义的信息。</li>
</ul>
</blockquote>
<h2 id="2-3-RADIUS报文介绍"><a href="#2-3-RADIUS报文介绍" class="headerlink" title="2.3 RADIUS报文介绍"></a>2.3 RADIUS报文介绍</h2><h3 id="2-3-1-RADIUS认证报文类型"><a href="#2-3-1-RADIUS认证报文类型" class="headerlink" title="2.3.1 RADIUS认证报文类型"></a>2.3.1 RADIUS认证报文类型</h3><table>
<thead>
<tr>
<th>报文名</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><div style="width: 110pt">Access-Request</div></td>
<td><div style="width: 60pt">请求报文</div></td>
<td>认证请求报文，是RADIUS报文交互过程中的第一个报文，用来携带用户的认证信息（例如：用户名、密码等）。认证请求报文由RADIUS客户端发送给RADIUS服务器，RADIUS服务器根据该报文中携带的用户信息判断是否允许接入。</td>
</tr>
<tr>
<td>Access-Accept</td>
<td>响应报文</td>
<td>认证接受报文，是RADIUS服务器对RADIUS客户端发送的Access-Request报文的接受响应报文。如果Access-Request报文中的所有属性都可以接受（即认证通过），则发送该类型报文。RADIUS客户端收到此报文后，用户才能认证通过并被赋予相应的权限。</td>
</tr>
<tr>
<td>Access-Reject</td>
<td>响应报文</td>
<td>认证拒绝报文，是RADIUS服务器对RADIUS客户端的Access-Request报文的拒绝响应报文。如果Access-Request报文中的任何一个属性不可接受（即认证失败），则RADIUS服务器返回Access-Reject报文，用户认证失败。</td>
</tr>
<tr>
<td>Access-Challenge</td>
<td>响应报文</td>
<td>认证挑战报文。EAP中继认证时，RADIUS服务器接收到Access-Request报文中携带的用户名信息后，会随机生成一个MD5挑战字，同时将此挑战字通过Access-Challenge报文发送给用户。用户使用该挑战字对用户密码进行加密处理后，将新的用户密码信息通过Access-Request报文发送给RADIUS服务器。RADIUS服务器将收到的已加密的密码信息和本地经过加密运算后的密码信息进行对比，如果相同，则该用户为合法用户。</td>
</tr>
</tbody></table>
<h3 id="2-3-2-RADIUS报文结构"><a href="#2-3-2-RADIUS报文结构" class="headerlink" title="2.3.2 RADIUS报文结构"></a>2.3.2 RADIUS报文结构</h3><p>RADIUS协议是基于UDP协议的，RADIUS报文格式如下所示</p>
<p><img src="/2022/07/23/AAA%E6%A6%82%E8%BF%B0/image-20220704145004.png" alt="image4"></p>
<blockquote>
<p>Attribute字段详述: <a href="https://support.huawei.com/enterprise/zh/doc/EDOC1100242379/5a06b3ea#ZH-CN_CONCEPT_0176366146">Redius属性</a>.</p>
</blockquote>
<h2 id="2-4-RADIUS认证流程"><a href="#2-4-RADIUS认证流程" class="headerlink" title="2.4 RADIUS认证流程"></a>2.4 RADIUS认证流程</h2><ol>
<li><p> 当用户接入网络时，通过NAC机制，RADIUS客户端（即设备）可以获得想要接入网络的用户的 ‘用户名和密码’。</p>
</li>
<li><p>RADIUS客户端向RADIUS服务器发送 Access-Request 报文（包含用户名和密码信息）</p>
</li>
<li><p>RADIUS服务器对用户身份的合法性进行检验：</p>
<ul>
<li>如果用户身份合法，RADIUS服务器向RADIUS客户端返回Access-Accept报文</li>
<li>如果用户身份不合法，RADIUS服务器向RADIUS客户端返回Access-Reject报文</li>
</ul>
</li>
<li><p>RADIUS客户端，通过NAC机制，通知用户认证是否成功。</p>
</li>
</ol>
<h2 id="2-5-RADIUS客户端可支持的功能"><a href="#2-5-RADIUS客户端可支持的功能" class="headerlink" title="2.5 RADIUS客户端可支持的功能"></a>2.5 RADIUS客户端可支持的功能</h2><h3 id="2-5-1-可配置RADIUS报文重传机制"><a href="#2-5-1-可配置RADIUS报文重传机制" class="headerlink" title="2.5.1 可配置RADIUS报文重传机制"></a>2.5.1 可配置RADIUS报文重传机制</h3><ul>
<li>为避免由于网络故障、时延等原因导致RADIUS客户端无法收到RADIUS服务器的回应报文，可以在RADIUS客户端(NAS)可以配置RADIUS重传机制</li>
<li>报文重传机制有两个参数：<ul>
<li>重传间隔时间：一般默认值2s</li>
<li>最大重传次数：一般默认值5times</li>
</ul>
</li>
</ul>
<p>重传机制规则：</p>
<ol>
<li>如果达到重传间隔时间，RADIUS客户端未收到RADIUS服务器的响应报文，会再次发送认证请求报文</li>
<li>达到最大重传次数后，RADIUS客户端会停止重传</li>
</ol>
<h3 id="2-5-2-可配置RADIUS服务器选择机制"><a href="#2-5-2-可配置RADIUS服务器选择机制" class="headerlink" title="2.5.2 可配置RADIUS服务器选择机制"></a>2.5.2 可配置RADIUS服务器选择机制</h3><p>当网络中存在多台Radius服务器时，RADIUS客户端可以配置其下一种RADIUS服务器选择机制：</p>
<ul>
<li>RADIUS服务器主备算法</li>
<li>RADIUS服务器负载均衡算法</li>
</ul>
<blockquote>
<p><strong>RADIUS服务器主备算法</strong><br>主备算法根据配置RADIUS认证服务器的权重决定，优先向权重高服务器发送认证请求报文，如果此服务器没有回应，则向权重低的服务器发送认证请求报文</p>
</blockquote>
<blockquote>
<p><strong>RADIUS服务器负载均衡算法</strong><br>负载均衡算法根据RADIUS认证服务器的权重来分配认证请求报文发往的概率<br>E.g. RADIUS服务器1的权重为80，RADIUS服务器2的权重为20，认证请求报文发往1的概率为80%</p>
</blockquote>
<h3 id="2-5-3-可配置RADIUS-CoA-DM-功能"><a href="#2-5-3-可配置RADIUS-CoA-DM-功能" class="headerlink" title="2.5.3 可配置RADIUS CoA/DM 功能"></a>2.5.3 可配置RADIUS CoA/DM 功能</h3><p>CoA和DM是由==RADIUS服务端主动发起的请求==，需要RADIUS客户端开启此功能才能生效</p>
<blockquote>
<p><strong>Redius CoA</strong><br>CoA（Change of Authorization）是指用户认证成功后，Redius可以通过RADIUS协议来修改在线用户的权限或对其进行重认证</p>
<p><strong>Redius CoA的报文交互流程</strong><br><img src="/2022/07/23/AAA%E6%A6%82%E8%BF%B0/image-20220704165357.png" alt="image6"></p>
<ol>
<li> RADIUS服务器根据业务信息，向设备发送CoA-Request报文，请求更改用户的授权信息。该报文中可以包括ACL规则等授权信息。</li>
<li> 设备收到CoA-Request报文后，与设备上的用户信息匹配来识别用户。如果匹配成功，则更改用户的授权信息；如果匹配失败，则保持用户原有授权信息。</li>
<li>设备回应CoA-ACK/NAK报文。<pre><code>-   如果更改成功，则设备向RADIUS服务器回应CoA-ACK报文。
-   如果更改失败，则设备向RADIUS服务器回应CoA-NAK报文。
</code></pre>
</li>
</ol>
</blockquote>
<blockquote>
<p><strong>Redius DM</strong><br>DM（Disconnect Message）是指用户下线报文，即由RADIUS服务器主动发起的强制用户下线的报文</p>
<p><strong>Redius DM的报文交互流程</strong></p>
<blockquote>
<p><img src="/2022/07/23/AAA%E6%A6%82%E8%BF%B0/image-20220704165757.png" alt="image7"></p>
</blockquote>
<ol>
<li> 管理员在RADIUS服务器上强制用户下线，RADIUS服务器向设备发送DM-Request报文，请求用户下线。</li>
<li> 设备收到DM-Request报文后，与设备上的用户信息匹配来识别用户。如果匹配成功，则通知用户下线；如果匹配失败，则用户保持在线。</li>
<li>设备回应DM-ACK/NAK报文。<pre><code>-   如果用户成功下线，设备给RADIUS服务器回应DM-ACK报文。
-   如果用户未下线，设备给RADIUS服务器回应DM-NAK报文。
</code></pre>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Networking</category>
      </categories>
  </entry>
  <entry>
    <title>5G专网概述</title>
    <url>/2022/07/24/5G%E4%B8%93%E7%BD%91%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="1-移动网络概述"><a href="#1-移动网络概述" class="headerlink" title="1. 移动网络概述"></a>1. 移动网络概述</h2><p>不管是2G、3G、4G还是5G，移动通信网络主要由两个子系统组成</p>
<ol>
<li> 无线接入网（RAN）</li>
<li> 移动核心网</li>
</ol>
<h3 id="1-1-无线接入网-RAN"><a href="#1-1-无线接入网-RAN" class="headerlink" title="1.1 无线接入网(RAN)"></a>1.1 无线接入网(RAN)</h3><ul>
<li><p>  RAN负责管理无线部分，以高效利用频谱资源，并满足用户的服务质量需求</p>
</li>
<li><p>RAN的关键组件叫基站，不同时代的基站的别名不同</p>
<table>
<thead>
<tr>
<th>移动网络Generation</th>
<th>基站别名</th>
</tr>
</thead>
<tbody><tr>
<td><div style="width: 150pt">2G</div></td>
<td><div style="width: 150pt">BTS</div></td>
</tr>
<tr>
<td>3G</td>
<td>NodeB</td>
</tr>
<tr>
<td>4G</td>
<td>eNB</td>
</tr>
<tr>
<td>5G</td>
<td>gNB</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="1-2-移动核心网"><a href="#1-2-移动核心网" class="headerlink" title="1.2 移动核心网"></a>1.2 移动核心网</h3><p>在移动网络的核心网中，可以分成两个网络面：==控制面和用户面==<br><img src="/2022/07/24/5G%E4%B8%93%E7%BD%91%E6%A6%82%E8%BF%B0/image-20220717205649.png" alt="image1"></p>
<table>
<thead>
<tr>
<th>核心网网络面</th>
<th>网络面作用</th>
</tr>
</thead>
<tbody><tr>
<td><div style="width: 150pt">控制面</div></td>
<td><div style="width: 150pt">承载信令或控制消息</div></td>
</tr>
<tr>
<td>用户面(也叫数据面或转发面)</td>
<td>承载数据流量</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>移动核心网的能力</strong></p>
<ol>
<li><p>移动核心网在RAN和Internet之间架起了一道桥梁，为数据和语音服务提供Internet连接</p>
</li>
<li><p> 确保连接的QoS质量要求</p>
</li>
<li><p> 管理用户移动性，以确保服务不中断</p>
</li>
<li><p> 计费</p>
</li>
</ol>
</blockquote>
<blockquote>
<p><strong>终端用户通过移动网络建立会话的过程概述</strong><br>终端上网时，基站会为终端建立无线信道连接。这个过程主要分为控制面连接和用户面连接两个阶段：<br>    1.  首先，基站会在手机和核心网的控制面之间建立“控制面”连接，并在两者之间转发信令消息，这些消息包括手机身份验证、注册、移动性管理等。<br>    2.  然后，基站会在手机和核心网的用户面之间建立“用户面”连接，转发用户数据流量</p>
</blockquote>
<hr>
<h2 id="2-第四代4G-LTE核心网"><a href="#2-第四代4G-LTE核心网" class="headerlink" title="2. 第四代4G-LTE核心网"></a>2. 第四代4G-LTE核心网</h2><h3 id="2-1-4G核心网分类"><a href="#2-1-4G核心网分类" class="headerlink" title="2.1 4G核心网分类"></a>2.1 4G核心网分类</h3><p>4G-LTE核心网被称作 EPC（Evolved Packet Core）<br>EPC可以分成两类：</p>
<ul>
<li>传统的LTE核心网: 仅支持接入LTE基站</li>
<li>升级的LTE核心网(EPC+): 不仅支持接入LTE基站，也可支持接入5G基站</li>
</ul>
<h3 id="2-2-4G核心网架构"><a href="#2-2-4G核心网架构" class="headerlink" title="2.2 4G核心网架构"></a>2.2 4G核心网架构</h3><p><img src="/2022/07/24/5G%E4%B8%93%E7%BD%91%E6%A6%82%E8%BF%B0/image-20220717211223.png" alt="image2"></p>
<p>如图，4G核心网主要由以下网元(Network Function)组成</p>
<blockquote>
<p><strong>控制面</strong>：</p>
<table>
<thead>
<tr>
<th>网元名称</th>
<th>网元功能</th>
</tr>
</thead>
<tbody><tr>
<td><div style="width: 140pt">MME(移动性管理实体)</div></td>
<td><div style="width: 300pt">负责追踪和管理终端在RAN中的移动性</div></td>
</tr>
<tr>
<td>HSS(归属用户服务器)</td>
<td>一个数据库，存储与用户签约相关的信息</td>
</tr>
<tr>
<td>PCRF(策略和计费规则)</td>
<td>负责策略控制决策和流量计费</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><strong>用户面</strong>：</p>
<table>
<thead>
<tr>
<th>网元名称</th>
<th>网元功能</th>
</tr>
</thead>
<tbody><tr>
<td><div style="width: 140pt"> SGW(服务网关) </div></td>
<td><div style="width: 300pt"> 本质上是IP路由器，主要负责与RAN之间转发IP数据包</div></td>
</tr>
<tr>
<td>PGW(分组网关)</td>
<td>本质上是IP路由器，将核心网连接到外部Internet</td>
</tr>
</tbody></table>
</blockquote>
<hr>
<h2 id="3-第五代5G核心网"><a href="#3-第五代5G核心网" class="headerlink" title="3. 第五代5G核心网"></a>3. 第五代5G核心网</h2><h3 id="3-1-5G核心网概述"><a href="#3-1-5G核心网概述" class="headerlink" title="3.1 5G核心网概述"></a>3.1 5G核心网概述</h3><p>5G核心网被称作NGC（Next Generation Core）。<br>NGC是依据5G标准新建的核心网，仅支持接入5G基站。</p>
<h3 id="3-2-5G核心网架构"><a href="#3-2-5G核心网架构" class="headerlink" title="3.2 5G核心网架构"></a>3.2 5G核心网架构</h3><p><img src="/2022/07/24/5G%E4%B8%93%E7%BD%91%E6%A6%82%E8%BF%B0/image-20220717211748.png" alt="image3"></p>
<p>5G核心网主要由以下网元(Network Function)组成:</p>
<blockquote>
<p><strong>控制面</strong>：</p>
<table>
<thead>
<tr>
<th>网元名称</th>
<th>网元功能</th>
<th>4G核心网对应网元</th>
</tr>
</thead>
<tbody><tr>
<td><div style="width: 160pt"> AMF(接入和移动性管理功能)</div></td>
<td>负责终端的移动性和接入管理，包括接入、连接、移动性管理，以及鉴权、位置服务等</td>
<td><div style="width: 140pt"> 大致对应4G EPC中的MME的功能</div></td>
</tr>
<tr>
<td>UDM(统一数据管理)</td>
<td>管理用户数据，包括用户标识、用户签约数据、鉴权数据等</td>
<td>大致对应4G EPC的HSS的部分功能</td>
</tr>
<tr>
<td>PCF(策略控制功能)</td>
<td>负责策略控制</td>
<td>大致对应4G EPC中的PCRF功能</td>
</tr>
<tr>
<td>AUSF(鉴权服务器功能)</td>
<td>就是鉴权服务器，配合UDM专门负责用户鉴权</td>
<td>/</td>
</tr>
<tr>
<td>NEF(网络开放功能)</td>
<td>通过API接口将，将其他网元的业务能力开放给第三方服务商</td>
<td>/</td>
</tr>
<tr>
<td>NRF(网络功能库)</td>
<td>负责对其他网元进行服务注册登记、状态监测等；并允许每个网元可以发现其它其他网元提供的服务。类似Keystone</td>
<td>/</td>
</tr>
<tr>
<td>NSSF(网络切片选择功能)</td>
<td>管理网络切片相关信息，比如负责为终端选择网络切片</td>
<td>/</td>
</tr>
<tr>
<td>SMF(会话管理功能)</td>
<td>==负责会话管理功能，包括IP地址分配、QoS控制、转发路由控制等==</td>
<td>大致对应MME的部分功能加上S/PGW的部分控制面功能</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><strong>用户面</strong>：</p>
<table>
<thead>
<tr>
<th>网元名称</th>
<th>网元功能</th>
<th>4G核心网对应网元</th>
</tr>
</thead>
<tbody><tr>
<td><div style="width: 160pt"> UPF(用户面功能)</div></td>
<td>==负责在无线接入网和Internet之间转发流量、报告流量使用情况、QoS策略实施等==</td>
<td><div style="width: 140pt"> 对应4G EPC中的S/PGW的用户面</div></td>
</tr>
</tbody></table>
</blockquote>
<h3 id="3-3-5G核心网架构相比于4G核心网架构的提升"><a href="#3-3-5G核心网架构相比于4G核心网架构的提升" class="headerlink" title="3.3 5G核心网架构相比于4G核心网架构的提升"></a>3.3 5G核心网架构相比于4G核心网架构的提升</h3><ol>
<li> 5G核心网的控制面和用户面彻底分离，这使得用户面UPF可灵活下沉，并与边缘计算（MEC）一起分布式部署于更接近用户侧的边缘，从而可降低网络时延，使能低时延5G应用</li>
<li> 5G核心网采用基于服务的架构（SBA）设计，其通过云原生、无状态的VNF（虚拟化网络功能）和共享的数据层让5G核心网更加弹性、高效和灵活</li>
</ol>
<hr>
<h2 id="4-5G专网"><a href="#4-5G专网" class="headerlink" title="4. 5G专网"></a>4. 5G专网</h2><h3 id="4-1-5G专网的分类"><a href="#4-1-5G专网的分类" class="headerlink" title="4.1 5G专网的分类"></a>4.1 5G专网的分类</h3><p>5G专网分为两大类：</p>
<ol>
<li>  国家提供专用的5G频段，用于行业客户自行来组一套完整的5G网络(接入网和核心网都是完全独立的网络)。由于国家不开放私有化的网络频段，行业客户也没有能力去组建一套完整的5G网络，所以==不讨论==</li>
<li> 运营商通过切片技术，通过UPF分流，将用户的数据直接传送到用户的内网，==默认讨论5G专网是依靠此方法实现的==</li>
</ol>
<h3 id="4-1-5G专网的特性"><a href="#4-1-5G专网的特性" class="headerlink" title="4.1 5G专网的特性"></a>4.1 5G专网的特性</h3><ol>
<li> 终端到基站之间通信使用的是5G网络</li>
<li> 专网的数据是需要UPF设备进行分流的，上行不进入运营商的5G核心网</li>
</ol>
<p>只有同时满足以上两条才可以，否则不能算是专网</p>
<h3 id="4-2-5G专网图解"><a href="#4-2-5G专网图解" class="headerlink" title="4.2 5G专网图解"></a>4.2 5G专网图解</h3><p><img src="/2022/07/24/5G%E4%B8%93%E7%BD%91%E6%A6%82%E8%BF%B0/image-20220717213047.png" alt="image4"></p>
<blockquote>
<ol>
<li>在运营商的5G核心网中的SMF中定制园区专属的分流策略</li>
<li>SMF中的分流策略，下发到园区专属搭建的UPF上</li>
<li>终端上线之后只要接入园区内的eNB，会从SMF拿到一个内网地址</li>
<li>内网流量到达私有UPF之后，可以进行本地的边缘计算(MEC)，然后进入内网，这样的数据传输环节将大大减小(用户面流量不进入运营商5G核心网，也不进入互联网)</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Networking</category>
      </categories>
  </entry>
  <entry>
    <title>WLAN安全策略</title>
    <url>/2022/07/24/WLAN%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>WLAN的安全策略，是专门根据802.1协议家族定制的，每种安全策略体现了<strong>一整套安全机制</strong>，包括 </p>
<blockquote>
<ol>
<li>无线链路建立时的<strong>链路认证</strong>方式</li>
<li>无线用户上线时的<strong>用户接入认证</strong>方式和 </li>
<li>无线用户传输数据业务时的<strong>数据加密</strong>方式。</li>
</ol>
</blockquote>
<h3 id="1-WEP-基本不用了"><a href="#1-WEP-基本不用了" class="headerlink" title="1. WEP (基本不用了)"></a>1. WEP (基本不用了)</h3><ol>
<li><p>链路认证方式：</p>
<ul>
<li>如果选择开放系统认证方式，链路认证过程不需要WEP加密</li>
<li>如果选择共享密钥认证方式，链路认证过程中完成了密钥协商</li>
</ul>
</li>
<li><p>用户接入认证方式：<br> WEP没有用户认证方式</p>
</li>
<li><p>业务流量加密方式：<br> WEP-40<br> WEP-104<br> WEP-128</p>
</li>
</ol>
<hr>
<h3 id="2-WPA-WPA2"><a href="#2-WPA-WPA2" class="headerlink" title="2. WPA/WPA2"></a>2. WPA/WPA2</h3><ol>
<li>链路认证方式：</li>
</ol>
<ul>
<li>WPA/WPA2仅支持开放式系统认证</li>
<li>WPA/WPA2不支持共享密钥认证</li>
</ul>
<ol start="2">
<li> 用户接入认证方式：  </li>
</ol>
<ul>
<li>WPA/WPA2企业版：<ul>
<li>802.1X</li>
</ul>
</li>
<li>WPA/WPA2个人版：<ul>
<li>PSK</li>
<li>PPSK</li>
<li>DPSK</li>
</ul>
</li>
</ul>
<blockquote>
<p>由于这个密钥仅仅用于认证过程，而不用于加密过程; 因此不会导致WEP中，不同的用户都采用相同的WEP密钥进行业务流量加密的问题</p>
</blockquote>
<blockquote>
<p>PSK使用的密钥类型有两类:<br>HEX：该输入项长度范围是8～32位16进制数且长度必须为偶数。<br>PASS-PHRASE：该输入项范围是8～64个字符。</p>
</blockquote>
<ol start="3">
<li><p>数据加密</p>
<p> WPA/WPA2支持TKIP和CCMP两种加密算法</p>
</li>
</ol>
<ul>
<li>TKIP加密算法: 区别于WEP共用一个共享密钥，TKIP采用一套动态密钥协商和管理方法，每个无线用户都会动态地协商一套密钥，保证了每个用户使用独立的密钥</li>
<li>CCMP加密算法(基于AES): 区别于WEP和TKIP采用的流密码机制，CCMP采用了以高级加密标准<strong>AES</strong>（Advanced Encryption Standard）的块密码为基础的安全协议</li>
</ul>
<blockquote>
<p>WPA和WPA2都可以使用<br>802.1X的接入认证<br>TKIP或CCMP的加密算法<br>他们之间的不同主要表现在协议报文格式上</p>
</blockquote>
<hr>
<h3 id="3-WPA3"><a href="#3-WPA3" class="headerlink" title="3. WPA3"></a>3. WPA3</h3><ol>
<li> 链路认证方式：</li>
</ol>
<ul>
<li>  WPA3仅支持开放式系统认证（WAP3在开放式系统认证的基础上做了升级，提出了OWE认证）</li>
<li>  WPA3不支持共享密钥认证</li>
</ul>
<ol start="2">
<li>用户接入认证方式：</li>
</ol>
<ul>
<li>WPA3企业版：<ul>
<li>  802.1X</li>
</ul>
</li>
<li>WPA3个人版：<ul>
<li>  SAE (取代了WPA2中的PSK)</li>
</ul>
</li>
</ul>
<ol start="3">
<li><p>数据加密</p>
<ul>
<li>WPA3仅支持AES加密算法</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-WPI"><a href="#4-WPI" class="headerlink" title="4. WPI"></a>4. WPI</h3><ol>
<li> 链路认证方式：</li>
</ol>
<ul>
<li>  WPA3仅支持开放式系统认证</li>
<li>  WPA3不支持共享密钥认证</li>
</ul>
<ol start="2">
<li>用户接入认证方式：</li>
</ol>
<ul>
<li> PSK</li>
<li>证书认证</li>
</ul>
<ol start="3">
<li>数据加密<br>通过密钥协商阶段产生的对称加密密钥，对业务数据进行加密<br>对称加密算法为：国密办审判的分组加密算法(SMS4)<br>WPI支持对称加密的 密钥更新</li>
</ol>
]]></content>
      <categories>
        <category>Networking</category>
      </categories>
  </entry>
  <entry>
    <title>IPtables</title>
    <url>/2022/07/27/IPtables/</url>
    <content><![CDATA[<h1 id="1-Iptables简介"><a href="#1-Iptables简介" class="headerlink" title="1. Iptables简介"></a>1. Iptables简介</h1><p>netfilter/iptables（简称为iptables）组成Linux平台下的包过滤防火墙，与大多数的Linux软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换（NAT）等功能。</p>
<blockquote>
<p><strong>iptables和netfilter是什么关系？</strong><br>很多的知道iptables却不知道 netfilter。其实iptables只是Linux防火墙的管理工具而已，位于/sbin/iptables。真正实现防火墙功能的是 netfilter实现的，它是Linux内核中实现包过滤的内部结构。</p>
</blockquote>
<blockquote>
<p><strong>iptables的逻辑结构？</strong><br>Iptables采用“表”和“链”的分层结构。在REHL4中是三张表五个链。现在REHL5成了<strong>四张表五个链</strong>了，不过多出来的那个表用的也不太多，所以基本还是和以前一样。注意一定要明白这些表和链的关系及作用。</p>
</blockquote>
<h2 id="1-1-Iptables的工作过程"><a href="#1-1-Iptables的工作过程" class="headerlink" title="1.1 Iptables的工作过程"></a>1.1 Iptables的工作过程</h2><blockquote>
<p><strong>数据包处理过程</strong></p>
<ul>
<li>数据包进入协议栈之后，会根据情况历经必要的”Chain”</li>
<li>数据包在每个”Chain”里面，都会历经”Chain”中存在的”table”</li>
<li>数据包在每个”Table”里面，都会历经”Table”中存在的”Rule” </li>
</ul>
</blockquote>
<blockquote>
<p><strong>Rule的定义</strong><br>Iptables的Rule和ACL类似，需要定义”匹配条件”和”处理动作”</p>
</blockquote>
<blockquote>
<p><strong>Rule的处理逻辑</strong></p>
<ul>
<li>一个Table中，按照Rule的顺序从上到下，从前到后进行匹配；</li>
<li>一经匹配，立即处理，不再向下匹配这个Table中规则了，进入下一张Table；</li>
<li>如果一个Table所有规则都没有匹配上，则进入下一个Table；</li>
<li>所有的Chain中所有的Table都没有规则匹配上，则按照默认策略进行处理。</li>
</ul>
</blockquote>
<hr>
<h1 id="2-Iptables四表五链"><a href="#2-Iptables四表五链" class="headerlink" title="2. Iptables四表五链"></a>2. Iptables四表五链</h1><p><img src="/2022/07/27/IPtables/image-20220725144204.png" alt="image1"></p>
<blockquote>
<p><strong>五链</strong></p>
<table>
<thead>
<tr>
<th align="left">链名</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">INPUT</td>
<td align="left">进来的数据包应用此规则链中的策略</td>
</tr>
<tr>
<td align="left">OUTPUT</td>
<td align="left">外出的数据包应用此规则链中的策略</td>
</tr>
<tr>
<td align="left">FORWARD</td>
<td align="left">转发数据包时应用此规则链中的策略</td>
</tr>
<tr>
<td align="left">PREROUTING</td>
<td align="left">对数据包作路由选择前应用此链中的规则<br>（所有的数据包进来协议栈的时侯都先由这个链处理）</td>
</tr>
<tr>
<td align="left">POSTROUTING</td>
<td align="left">对数据包作路由选择后应用此链中的规则<br>（所有的数据包出去协议栈的时侯都会由这个链处理）</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><strong>四表</strong></p>
<p>每张表可以定义在哪条链中，见图</p>
<table>
<thead>
<tr>
<th align="left">表名</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">filter表</td>
<td align="left">过滤数据包，内核模块iptables_filter实现</td>
</tr>
<tr>
<td align="left">Nat表</td>
<td align="left">用于网络地址转换（IP、端口，由内核模块iptable_nat实现</td>
</tr>
<tr>
<td align="left">Mangle表</td>
<td align="left">修改数据包的服务类型、TTL、并且可以配置路由实现QOS，由内核模块：iptable_mangle实现 (几乎不会用这张表)</td>
</tr>
<tr>
<td align="left">Raw表</td>
<td align="left">决定数据包是否被状态跟踪机制处理，由内核模块iptable_raw实现 (几乎不会用这张表)</td>
</tr>
</tbody></table>
</blockquote>
<blockquote>
<p><strong>五链的优先级顺序</strong></p>
<ol>
<li><p>第一种情况：入站数据流向(数据包是发往本机的)<br> PREROUTING – INPUT</p>
</li>
<li><p>第二种情况：转发数据流向(数据在本机路由的)<br> PREROUTING – FORWARD – POSTROUTING</p>
</li>
<li><p>第三种情况：出站数据流向(数据是本机生成的)<br> OUTPUT – POSTROUTING</p>
</li>
</ol>
</blockquote>
<blockquote>
<p><strong>四表的优先级顺序</strong><br>    raw —— mangle —— nat —— filter</p>
</blockquote>
<h1 id="3-Iptables命令"><a href="#3-Iptables命令" class="headerlink" title="3. Iptables命令"></a>3. Iptables命令</h1><h2 id="3-1-iptables命令详情"><a href="#3-1-iptables命令详情" class="headerlink" title="3.1 iptables命令详情"></a>3.1 iptables命令详情</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -t 表名 &lt;-A/I/D/R&gt; 规则链名 [规则号] &lt;-i/o 网卡名&gt; -p 协议名 &lt;-s 源IP/源子网&gt; --sport 源端口 &lt;-d 目标IP/目标子网&gt; --dport 目标端口 -j 动作</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-t, --table table：对指定的表 table 进行操作， table 必须是 raw， nat，filter，mangle 中的一个。如果不指定此选项，默认的是 filter 表。</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通用匹配：源地址目标地址的匹配</span></span><br><span class="line">-p：指定要匹配的数据包协议类型；</span><br><span class="line">-s, --source [!] address[/mask] ：把指定的一个／一组地址作为源地址，按此规则进行过滤。当后面没有 mask 时，address 是一个地址，比如：192.168.1.1；当 mask 指定时，可以表示一组范围内的地址，比如：192.168.1.0/255.255.255.0。</span><br><span class="line">--sport 源端口</span><br><span class="line">-d, --destination [!] address[/mask] ：地址格式同上，但这里是指定地址为目的地址，按此进行过滤。</span><br><span class="line">--dport 目标端口</span><br><span class="line">-i, --in-interface [!] &lt;网络接口name&gt; ：指定数据包的来自来自网络接口，比如最常见的 eth0 。注意：它只对 INPUT，FORWARD，PREROUTING 这三个链起作用。如果没有指定此选项， 说明可以来自任何一个网络接口。同前面类似，&quot;!&quot; 表示取反。</span><br><span class="line">-o, --out-interface [!] &lt;网络接口name&gt; ：指定数据包出去的网络接口。只对 OUTPUT，FORWARD，POSTROUTING 三个链起作用。</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看管理命令</span></span><br><span class="line">-L, --list [chain] 列出链 chain 上面的所有规则，如果没有指定链，列出表上所有链的所有规则。</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">规则管理命令</span></span><br><span class="line">-A, --append chain rule-specification 在指定链 chain 的末尾插入指定的规则，也就是说，这条规则会被放到最后，最后才会被执行。规则是由后面的匹配来指定。</span><br><span class="line">-I, --insert chain [rulenum] rule-specification 在链 chain 中的指定位置插入一条或多条规则。如果指定的规则号是1，则在链的头部插入。这也是默认的情况，如果没有指定规则号。</span><br><span class="line">-D, --delete chain rule-specification -D, --delete chain rulenum 在指定的链 chain 中删除一个或多个指定规则。</span><br><span class="line">-R num：Replays替换/修改第几条规则</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">动作参数</span></span><br><span class="line">-j, --jump target &lt;指定目标&gt; ：即满足某条件时该执行什么样的动作。target 可以是内置的目标，比如 ACCEPT，也可以是用户自定义的链。</span><br></pre></td></tr></table></figure>


<h2 id="3-2-iptables常用命令"><a href="#3-2-iptables常用命令" class="headerlink" title="3.2 iptables常用命令"></a>3.2 iptables常用命令</h2><p><strong>查看iptables规则</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -L [链名][-t 表名]   <span class="comment"># 查看iptables规则</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -L -vn   <span class="comment"># 查看iptables规则(详细信息)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>添加iptables规则</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -t <span class="comment"># 指定表(default: `filter&#x27;)</span></span>  </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -A <span class="comment"># 把规则添加到指定的链上，默认添加到最后一行</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -I <span class="comment"># 把规则插入到指定的链上，默认插入到第一行</span></span></span><br></pre></td></tr></table></figure>

<p><strong>删除iptables规则</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -nL --line-numbers <span class="comment"># 查看规则号码</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -D [chain] [规则号] <span class="comment"># 删除指定链上的指定序号</span></span></span><br></pre></td></tr></table></figure>

<p><strong>清空iptables规则</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">iptables -F [chain] <span class="comment"># 清除指定链上所有规则，不会处理默认的规则</span></span></span><br></pre></td></tr></table></figure>

<p><strong>iptables实际场景配置</strong><br><a href="https://blog.csdn.net/weixin_45186298/article/details/122910466">https://blog.csdn.net/weixin_45186298/article/details/122910466</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Open vSwitch</title>
    <url>/2022/07/27/OVS/</url>
    <content><![CDATA[<h1 id="1-OVS概述"><a href="#1-OVS概述" class="headerlink" title="1. OVS概述"></a>1. OVS概述</h1><p><strong>OVS简介</strong></p>
<p>Open vSwitch简称OVS，OVS是一个支持多层数据转发的高质量虚拟交换机，主要部署在服务器上，相比传统交换机具有很好的编程扩展性，同时具备传统交换机实现的网络隔离和数据转发功能，运行在每个实现虚拟化的物理机器上，并提供远程管理。</p>
<blockquote>
<p>OVS支持两种远程管理的协议</p>
<ol>
<li>OpenFlow，通过流表来管理虚拟交换机的行为 (OpenFlow协议可用于定于SDN网络，实现网络转发平面和控制平面分离)</li>
<li>一个是OVSDB管理协议，用来暴露虚拟交换机的本身属性(比如端口状态）</li>
</ol>
</blockquote>
<p><strong>OVS架构</strong><br><img src="/2022/07/27/OVS/image-20220726223326.png" alt="image1"></p>
<blockquote>
<p><strong>OVS主要包含三个基本组件：</strong></p>
<ol>
<li><strong>ovs-vswtichd:</strong> 是OVS的主要模块，运行在用户态，其主要负责基本的转发逻辑、地址学习、外部物理端口绑定等。可接收openflow报文</li>
<li><strong>ovsdb-server:</strong> 是存储OVS的网桥等配置、日志以及状态的轻量级数据库。它与ovs-vswitchd都是以一个单独的进程存在于系统中。ovsdb是一个可提供持久化存储的数据库，可借助ovs-vsctl工具配置OVS交换机，配置信息将保存在ovsdb中。ovs-vswitchd组件与ovsdb-server组件间的通信采用OVSDB管理协议。</li>
<li><strong>openvswitch.ko:</strong> 运行在内核态，属于快速转发平面，主要负责流表匹配、报文修改、隧道封装、转发或者上送，并且维护底层转发表。在原始OVS中，报文首先经过该组件完成报文解析和封装、转发规则匹配。若匹配到转发规则，直接转发，不进入用户态；若没有匹配到转发规则直接转发，进入用户态的ovs-vswitchd组件进行处理。ovs-vswitchd组件与openvswitch.ko组件之间采用netlink执行进程间的通信。netlink是一种进程间通信机制，可用于处理用户态和内核态的通信</li>
</ol>
</blockquote>
<blockquote>
<p><strong>OVS中的流表</strong><br>在OVS中有两个流表，一个为位于内核空间的内核态流表，另一个是位于用户空间的用户态流表</p>
<ol>
<li>用户态流表: 用户态流表表项主要由sdn控制器或人为通过ovs-ofctl工具下发生成。</li>
<li>内核态流表: 内核态流表主要是存储近期匹配过得流表项, 内核态流表中的表项，通过用户态表项下发生成。</li>
</ol>
</blockquote>
<hr>
<h1 id="2-OVS报文处理机制"><a href="#2-OVS报文处理机制" class="headerlink" title="2. OVS报文处理机制"></a>2. OVS报文处理机制</h1><h2 id="2-1-传统OVS"><a href="#2-1-传统OVS" class="headerlink" title="2.1 传统OVS"></a>2.1 传统OVS</h2><blockquote>
<p><strong>什么是传统OVS？</strong></p>
<ul>
<li>在传统OVS中，网卡通过内核驱动绑定到OVS端口上</li>
<li>OVS端口的数据包接收和发送函数都是在datapath中定义的，因此报文的接收和发送统一由位于内核空间的datapath进行，datapath已经引入各个Linux发行版内核</li>
<li>内核空间负责报文的解析封装、流表匹配、流表匹配失败上送、报文转发或丢弃等报文处理操作</li>
</ul>
</blockquote>
<blockquote>
<p><strong>传统OVS转发流程</strong><br><img src="/2022/07/27/OVS/image-20220726180929.png" alt="image2"></p>
<ul>
<li>当数据包在内核态流表中可以匹配到流表项，数据包将不经过用户空间，直接由内核进行action操作并将报文转发或丢弃。</li>
<li>若数据包在内核态流表中未匹配到流表项，将使用Linux系统的Netlink通信机制实现内核进程和用户进程的通信，把数据包上送到用户空间，进行用户态流表匹配，若命中用户态流表项，则在用户空间中完成流表项相应的action操作，最终获得数据包的出端口信息并告知内核中的datapath如何将数据包转发出去，并且同时将命中到的用户态流表项，以内核态流表的规则生成对应的内核态流表项，下发至内核态流表。</li>
<li>若数据包在用户态流表中也未匹配到流表项，则将数据包丢弃或者上送至控制器，由控制器决定如何转发该数据包</li>
</ul>
</blockquote>
<h2 id="2-2-OVS-DPDK"><a href="#2-2-OVS-DPDK" class="headerlink" title="2.2 OVS+DPDK"></a>2.2 OVS+DPDK</h2><blockquote>
<p><strong>什么是OVS+DPDK？</strong></p>
<ul>
<li>DPDK平台提供的接口库，可以将底层环境资源做抽象，即在系统中新增了环境抽象层（EAL），将网卡驱动在用户态实现，通过这个用户态驱动来驱动物理网卡，将网卡绑定到OVS端口上</li>
<li>所以到达网口的数据包会直接交给用户空间的进程进行处理</li>
<li>发送报文到这个OVS接口的时候，也会将报文直接发送到对应网卡</li>
<li>在OVS的vswitchd进程中新起一个数据收发接管线程（TO-Thread）取代传统OVS中由datapath执行的数据包接收和发送的功能</li>
</ul>
</blockquote>
<blockquote>
<p><strong>OVS+DPDK转发流程</strong><br><img src="/2022/07/27/OVS/image-20220726202721.png" alt="image3"></p>
<ul>
<li>当报文到达网卡，EAL使用用户态网卡驱动，将报文发送到用户空间交给TO-Thread线程进行接管</li>
<li>在该TO-Thread线程中将进行报文的解析，然后在vswitchd进程完成与用户态流表的匹配</li>
<li>若数据包命中用户态流表项，TO-Thread线程根据表项进行action处理，将数据包转发或丢弃</li>
<li>若数据包在用户态流表中未匹配到流表项，则将数据包丢弃或者上送至控制器，由控制器决定如何转发该数据包<br>(Note: 接收报文的过程中完全不经过OVS中内核态的datapath进程的处理和内核态流表的匹配)</li>
</ul>
</blockquote>
<hr>
<h1 id="3-OVS中的网络设备术语"><a href="#3-OVS中的网络设备术语" class="headerlink" title="3. OVS中的网络设备术语"></a>3. OVS中的网络设备术语</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">cic1:~ # ovs-vsctl show</span><br><span class="line">Bridge br_prv</span><br><span class="line">    fail_mode: secure</span><br><span class="line">    datapath_type: netdev</span><br><span class="line">    Port &quot;patch_br_prv_br_lcm_om_ipv4&quot;</span><br><span class="line">        tag: 1407</span><br><span class="line">        Interface &quot;patch_br_prv_br_lcm_om_ipv4&quot;</span><br><span class="line">                type: patch</span><br><span class="line">                options:&#123;peer=&quot;patch_br_lcm_om_ipv4_br_prv&quot;&#125;</span><br><span class="line">    Port patch_br_prv_br_cee_om</span><br><span class="line">        tag: 1405</span><br><span class="line">        Interface patch_br_prv_br_cee_om</span><br><span class="line">            type: patch</span><br><span class="line">            options: &#123;peer=patch_br_cee_om_br_prv&#125;</span><br><span class="line">    Port phy-br_prv</span><br><span class="line">        Interface phy-br_prv</span><br><span class="line">            type: patch</span><br><span class="line">            options: &#123;peer=int-br_prv&#125;</span><br><span class="line">    Port patch_br_prv_br_lcm_om</span><br><span class="line">        tag: 1406</span><br><span class="line">        Interface patch_br_prv_br_lcm_om</span><br><span class="line">            type: patch</span><br><span class="line">            options: &#123;peer=patch_br_lcm_om_br_prv&#125;</span><br><span class="line">    Port bond_prv</span><br><span class="line">        Interface &quot;data1&quot;</span><br><span class="line">            type: dpdk</span><br><span class="line">            options: &#123;dpdk-devargs=&quot;0000:1a:00.1&quot;, dpdk-lsc-interrupt=False, n_rxq_desc=&quot;1024&quot;, n_txq_desc=&quot;1024&quot;&#125;</span><br><span class="line">        Interface &quot;data0&quot;</span><br><span class="line">            type: dpdk</span><br><span class="line">            options: &#123;dpdk-devargs=&quot;0000:1a:00.0&quot;, dpdk-lsc-interrupt=False, n_rxq_desc=&quot;1024&quot;, n_txq_desc=&quot;1024&quot;&#125;</span><br><span class="line">    Port br_prv</span><br><span class="line">        Interface br_prv</span><br><span class="line">            type: internal</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Bridge</strong><br>网桥，即虚拟交换机(vSwitch)，一台主机中可创建一个或多个Bridge。Bridge可根据一定的规则，把某个端口接收到的数据报文转发到另一个或多个端口上，也可以修改或者丢弃数据报文</p>
</blockquote>
<blockquote>
<p><strong>Port</strong>:<br>端口，即虚拟交换机上的虚拟端口。有以下几种类型：</p>
<ol>
<li><strong>Normal</strong>：传统OVS端口</li>
<li><strong>DPDK</strong>：DPDK端口</li>
<li><strong>Internal</strong>：此类型的Port，为vSwitch的本机本地端口</li>
<li><strong>Patch</strong>：与 veth pair 功能相同，可看作是一根网线，常用于连接两个Bridge</li>
<li><strong>Tunnel</strong>：实现overlay网络。支持 GRE、VXLAN、STT、Geneve和IPSec等隧道协议</li>
</ol>
</blockquote>
<blockquote>
<p><strong>Interface</strong>:<br>网卡，每一个port可以绑定一个或多个Interface，Interface可以是虚拟的(TUN/TAP)，物理网卡、DPDK驱动的物理网卡。</p>
</blockquote>
<hr>
<h1 id="4-OpenFlow"><a href="#4-OpenFlow" class="headerlink" title="4. OpenFlow"></a>4. OpenFlow</h1><blockquote>
<p><strong>什么是OpenFlow？</strong></p>
<p>SDN核心思想是将传统网络设备的控制面和转发面进行分离，在这种分离架构中，通过高层的控制平面灵活、高效地定制个性化的转发策略，将转发策略下发到转发面，转发面根据转发策略进行数据转发。</p>
<p>控制面和转发面之间的通信靠什么协议实现？<br>OpenFlow协议就是专门用来完整控制面下发转发策略给控制面而设计的协议。</p>
<p>OpenFlow控制器: 就是可以生成转发策略封装，并支持OpenFlow协议的控制器<br>OpenFlow交换机: 就是可以接收OpenFlow协议，并且可以解析出其中的转发规则，并且可以按照转发规则转发数据包的交换机</p>
</blockquote>
<blockquote>
<p><strong>OpenFlow中携带的转发策略是如何具象体现的？</strong><br>通过流表项(Flow Entry)，流表项组成流表(Flow Table)</p>
<ul>
<li>OpenFlow控制器生成流表项，通过OpenFlow协议下发给OpenFlow虚拟交换机</li>
<li>OpenFlow虚拟交换机通过其维护的流表决定数据包如何转发</li>
</ul>
</blockquote>
<h2 id="4-1-流表-项-结构"><a href="#4-1-流表-项-结构" class="headerlink" title="4.1 流表(项)结构"></a>4.1 流表(项)结构</h2><p>流表在OVS中充当传统物理交换机的MAC表和路由表的角色，数据包在交换机内部端口间的转发规则由流表中的流表项决定。OVS中的流表由多个流表项组成，流表项结构如图：</p>
<blockquote>
<p><img src="/2022/07/27/OVS/image-20220726210344.png" alt="image4"></p>
<ul>
<li>匹配域：用于匹配数据包</li>
<li>优先级：用于指定流表项的优先级，<strong>数值越大优先级越高</strong></li>
<li>计数器：用于统计数据量的相关信息，例如一条流表项别匹配到的次数</li>
<li>指令集：表示当数据包匹配到该流表项时，需要执行的动作</li>
<li>计时器：用于设定流表项的超时时间，当一条流表项，在其超时时间内未被匹配到一次，此流表项将被删除</li>
</ul>
</blockquote>
<blockquote>
<p><strong>匹配域可以定义哪些匹配条件？</strong><br><img src="/2022/07/27/OVS/image-20220726211934.png" alt="image5"><br><a href="https://blog.csdn.net/elihe2011/article/details/122346128">匹配条件汇总1</a>.<br><a href="https://segmentfault.com/a/1190000038767587?utm_source=coffeephp.com">匹配条件汇总2</a>.</p>
</blockquote>
<blockquote>
<p><strong>一张流表当中的匹配规则</strong></p>
<ul>
<li>数据包和流表当中的所有表项进行匹配</li>
<li>如果一个数据包匹配到了多条表项，优先级打的表项生效</li>
<li>然后根据此表项中的指令集对该数据包进行相应操作</li>
<li>每个流表（Flow Table）都包含一个Table Miss流表项，该表项用于定义在流表中没有匹配的报文的处理方式，该表项的匹配域为通配，即匹配任何报文，优先级为0，指令集与正常表项相同。通常，如果Table-Miss表项不存在，默认行为是丢弃报文。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>匹配到表项后，支持什么指令(Instructions)？</strong></p>
<ol>
<li>Meter: 对匹配到的报文进行限速</li>
<li><strong>Actions:</strong> 对匹配到的报文立即执行动作</li>
<li>Goto-Table: 将报文引入指定的另一个FlowTable</li>
</ol>
</blockquote>
<blockquote>
<p><strong>Actions类型中有哪些动作？</strong><br>很多！！！比如</p>
<table>
<thead>
<tr>
<th align="left"><strong>action</strong></th>
<th align="left"><strong>comment</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">output:port</td>
<td align="left">将数据包转发到指定port</td>
</tr>
<tr>
<td align="left">local</td>
<td align="left">将数据包转发到local port</td>
</tr>
<tr>
<td align="left">in_port</td>
<td align="left">将数据包转发到接收此数据包的port</td>
</tr>
<tr>
<td align="left">drop</td>
<td align="left">丢弃数据包</td>
</tr>
<tr>
<td align="left">mod_dl_src:mac</td>
<td align="left">修改数据包源mac</td>
</tr>
<tr>
<td align="left">mod_nw_src:ip</td>
<td align="left">修改数据包源ip</td>
</tr>
<tr>
<td align="left">mod_vlan_vid:22</td>
<td align="left">修改数据包源vlanID</td>
</tr>
<tr>
<td align="left">Normal</td>
<td align="left">按照传统二层交换机机制转发数据包</td>
</tr>
</tbody></table>
</blockquote>
<p><strong>流表示例</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cic1:~ # ovs-ofctl dump-flows br-int</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38179.962s, table=0, n_packets=20, n_bytes=1480, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1431 actions=mod_vlan_vid:15,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38176.192s, table=0, n_packets=22, n_bytes=1628, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1420 actions=mod_vlan_vid:16,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38172.430s, table=0, n_packets=21, n_bytes=1554, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1430 actions=mod_vlan_vid:29,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38168.667s, table=0, n_packets=22, n_bytes=1628, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1465 actions=mod_vlan_vid:9,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38164.900s, table=0, n_packets=20, n_bytes=1480, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1435 actions=mod_vlan_vid:10,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38161.134s, table=0, n_packets=21, n_bytes=1554, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1462 actions=mod_vlan_vid:17,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38157.333s, table=0, n_packets=21, n_bytes=1554, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1432 actions=mod_vlan_vid:26,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38153.496s, table=0, n_packets=21, n_bytes=1554, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1423 actions=mod_vlan_vid:30,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38149.694s, table=0, n_packets=21, n_bytes=1554, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1468 actions=mod_vlan_vid:20,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38145.892s, table=0, n_packets=21, n_bytes=1554, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1445 actions=mod_vlan_vid:21,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38142.102s, table=0, n_packets=22, n_bytes=1628, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1440 actions=mod_vlan_vid:22,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38138.321s, table=0, n_packets=57417, n_bytes=4863096, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1470 actions=mod_vlan_vid:46,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38134.534s, table=0, n_packets=38147, n_bytes=2289100, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1444 actions=mod_vlan_vid:47,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38130.752s, table=0, n_packets=20, n_bytes=1480, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1451 actions=mod_vlan_vid:24,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38126.974s, table=0, n_packets=836652, n_bytes=88391047, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1438 actions=mod_vlan_vid:48,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38123.156s, table=0, n_packets=21, n_bytes=1554, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1436 actions=mod_vlan_vid:12,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38119.340s, table=0, n_packets=21, n_bytes=1554, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1467 actions=mod_vlan_vid:11,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38115.497s, table=0, n_packets=20, n_bytes=1480, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1450 actions=mod_vlan_vid:18,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38111.712s, table=0, n_packets=22, n_bytes=1628, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1446 actions=mod_vlan_vid:27,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38107.903s, table=0, n_packets=22, n_bytes=1628, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1433 actions=mod_vlan_vid:28,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38104.083s, table=0, n_packets=830949, n_bytes=72368689, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1455 actions=mod_vlan_vid:49,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38100.282s, table=0, n_packets=21, n_bytes=1554, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1443 actions=mod_vlan_vid:13,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38096.486s, table=0, n_packets=21, n_bytes=1554, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1449 actions=mod_vlan_vid:23,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38092.686s, table=0, n_packets=21, n_bytes=1554, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1441 actions=mod_vlan_vid:19,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38088.875s, table=0, n_packets=20, n_bytes=1480, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1422 actions=mod_vlan_vid:31,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38085.073s, table=0, n_packets=20, n_bytes=1480, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1464 actions=mod_vlan_vid:25,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38081.213s, table=0, n_packets=21, n_bytes=1554, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1437 actions=mod_vlan_vid:14,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38077.420s, table=0, n_packets=21, n_bytes=1554, priority=3,in_port=&quot;int-br_prv&quot;,dl_vlan=1439 actions=mod_vlan_vid:32,NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38198.763s, table=0, n_packets=940126, n_bytes=85647742, priority=2,in_port=&quot;int-br_prv&quot; actions=drop</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38212.084s, table=0, n_packets=1560158, n_bytes=146832681, priority=0 actions=NORMAL</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38211.133s, table=23, n_packets=0, n_bytes=0, priority=0 actions=drop</span><br><span class="line"> cookie=0x881e061ba93b7a87, duration=38210.190s, table=24, n_packets=0, n_bytes=0, priority=0 actions=drop</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-2-多级流表"><a href="#4-2-多级流表" class="headerlink" title="4.2 多级流表"></a>4.2 多级流表</h2><p>为了减少流表的开销(一张流表当中的流表项过多)，从OpenFlow 1.1版本开始设计了多级流表，每个OpenFlow交换机中可以由一个或多个流表组成</p>
<blockquote>
<p><strong>多级流表的匹配规则</strong></p>
<ul>
<li>当报文进入Switch后，必须从最小的Flow Table开始依次匹配</li>
<li>当报文匹配到的表项的动作集类型为Goto-Table时，报文进入到指定的table中</li>
<li>Flow Table可以按次序从小到大越级跳转，但不能从某一Flow Table向前跳转至编号更小的Flow Table</li>
</ul>
</blockquote>
<hr>
<h1 id="5-OVS相关指令"><a href="#5-OVS相关指令" class="headerlink" title="5. OVS相关指令"></a>5. OVS相关指令</h1><p>OVS的指令可以划分为三大类，控制面指令、管理面指令、数据面指令</p>
<blockquote>
<p><strong>管理面指令</strong><br>**<code>ovs-vsctl</code>**：查询和更新 ovs-vswitchd 的配置，这也是一个很强大的命令，网桥、端口、协议等相关的命令都由它来完成。<br>**<code>ovsdb-tool</code>**：ovsdb-tool 可以直接操作ovsdb数据库</p>
</blockquote>
<blockquote>
<p><strong>控制面指令</strong><br>**<code>ovs-ofctl</code>**：这个是控制面的模块，但本质上它也是一个管理工具，主要是基于 OpenFlow 协议对 OpenFlow 交换机进行监控和管理，通过它可以显示一个 OpenFlow 交换机的当前状态，包括功能、配置和表中的项。使用时，有很多参数，我们可以通过 ovs-ofctl –help 查看</p>
</blockquote>
<blockquote>
<p><strong>数据面指令</strong><br>**<code>ovs-appctl</code>**：查询和控制运行中的 OVS 守护进程(ovs-switchd)</p>
</blockquote>
<h2 id="5-1-ovs-vsctl"><a href="#5-1-ovs-vsctl" class="headerlink" title="5.1 ovs-vsctl"></a>5.1 ovs-vsctl</h2><p><strong>Bridge相关</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">添加bridge</span></span><br><span class="line">add-br br0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">列出当前存在的bridge</span></span><br><span class="line">ovs-vsctl list-br</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除bridge</span></span><br><span class="line">ovs-vsctl del-br br0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">检查bridge是否存在，不存在返回<span class="built_in">exit</span>=2</span></span><br><span class="line">ovs-vsctl br-exists br0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输出所有bridge的信息</span></span><br><span class="line">ovs-vsctl show</span><br></pre></td></tr></table></figure>

<p><strong>Port相关</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建Port，并且关联类型为Normal的Interface</span></span><br><span class="line">ovs-vsctl add-port br0 ens38</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建Port，并且关联类型为Internal的Interface</span></span><br><span class="line">ovs-vsctl add-port br0 int0 -- set interface int0 type=internal</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建Port，并且关联类型为DPDK的Interface</span></span><br><span class="line">ovs-vsctl add-port br0 dpdk0 -- set Interface dpdk0 type=dpdk options:dpdk-devargs=0000:03:00.0 (填写网卡PCI)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建Port，并且关联类型为Patch的Interface</span></span><br><span class="line">ovs-vsctl add-port br0 patch0 -- set interface patch0 type=patch options:peer=patch1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建Port，并且关联类型为Tunnel的Interface</span></span><br><span class="line">ovs-vsctl add-port br0 vxlan01 -- set interface vxlan01 type=vxlan options:remote_ip=192.168.3.104</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置Port的PVID</span></span><br><span class="line">ovs-vsctl set port p0 tag=100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置Port的Untagged</span></span><br><span class="line">ovs-vsctl set port p0 trunks=100,200</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Port的VLAN_mode</strong></p>
<ul>
<li>在默认模式下(VLAN_mode没被设置)，ovs端口默认是trunk模式，且可以放通所有的VLAN tag</li>
<li>一个Port只设定了trunks=100,200，进入trunk mode，就只能放通设定的VLAN tag了，不带tag的数据包，进入交换机后的VLAN为0</li>
<li>一个Port只设定了tag=100，进入access mode，access模式的端口只允许不带VLAN的数据包进入，数据包进入access端口后会被打上和端口tag相同的VLAN；而再从access端口出去时，数据包的VLAN会被删除</li>
<li>一个Port同时设定了tag=100, trunks=100,200, 相当于传统交换机的trunk口，PVID就是由tag指定的。</li>
</ul>
</blockquote>
<h2 id="5-1-ovs-ofctl"><a href="#5-1-ovs-ofctl" class="headerlink" title="5.1 ovs-ofctl"></a>5.1 ovs-ofctl</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看一个bridge的流表</span></span><br><span class="line">ovs-ofctl dump-flows br0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给bridge添加流表项</span></span><br><span class="line">ovs-ofctl add-flow br0 &quot;CONDITION, action=ACT1,ACT2...&quot;</span><br><span class="line">ovs-ofctl mod-flows br0 &quot;CONDITION, action=ACT1,ACT2...&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清空一个bridge的流表</span></span><br><span class="line">ovs-ofctl del-flows br0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除特定流表规则</span></span><br><span class="line">ovs-ofctl del-flows br0 &quot;CONDITION&quot;</span><br></pre></td></tr></table></figure>


<h1 id="6-OVS实战"><a href="#6-OVS实战" class="headerlink" title="6. OVS实战"></a>6. OVS实战</h1><p><a href="https://www.sdnlab.com/20196.html?from=singlemessage">OVS VxLAN组网</a></p>
<p><a href="https://blog.csdn.net/elihe2011/article/details/122346128">OVS VLAN组网</a></p>
]]></content>
      <categories>
        <category>Networking</category>
      </categories>
  </entry>
  <entry>
    <title>VxLAN</title>
    <url>/2022/07/27/VxLAN/</url>
    <content><![CDATA[<h2 id="1-现有的痛点"><a href="#1-现有的痛点" class="headerlink" title="1. 现有的痛点"></a>1. 现有的痛点</h2><ol>
<li><p>虚拟机规模受网络设备表项规格的限制</p>
<p> 以一台汇聚层交换机为例：</p>
<ul>
<li> 汇聚层的交换机需要学习大量的MAC地址表象(自己连接的每一台接入层交换机的mac地址表的总和）</li>
<li>  汇聚层交换机MAC地址表太多的话，交换机内存不足时，mac地址表象会溢出</li>
<li>  MAC地址表项溢出，会导致网络APR泛洪，降低网络性能</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>VxLAN如何解决的？</strong><br>VxLAN通过隧道技术实现三层的转发, VXLAN将虚拟机发出的数据包二次封装在UDP中，并使用VTEP的IP/MAC地址作为外层进行封装，对网络只表现为封装后的参数，因此，极大的降低了大二层网路对MAC地址规格的需求。</p>
</blockquote>
<ol start="2">
<li><p>VLAN隔离能力不在满足需求</p>
<ul>
<li>网络的二层隔离需求很高</li>
<li>利用vlan来隔离网络，当网络特别多的时候，vlan数不够(1-4094)</li>
<li>MAC地址表项溢出，会导致网络APR泛洪，降低网络性能</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>VxLAN如何解决的</strong><br>VXLAN网络标示VNI有24bit(1700w个)</p>
</blockquote>
<ol start="3">
<li>无法跨越三层设备传递二层mac地址信息</li>
</ol>
<ul>
<li>MAC地址是一个二层概念，无法跨越三层设备<br><img src="/2022/07/27/VxLAN/image-20220520141342.png" alt="image1"></li>
<li>host1要想和直接和mac4通信是不可能的，因为Switch1上没有mac4的信息<blockquote>
<p><strong>有什么场景需要跨三层设备实现二层可达？</strong></p>
<ol>
<li>VPN中，总部服务器，分部需要在一个二层环境中</li>
<li>虚拟机迁移，顾名思义，就是将虚拟机从一个物理机迁移到另一个物理机，但是要求在迁移过程中业务不能中断。要做到这一点，需要保证虚拟机迁移前后，其IP地址、MAC地址等参数维持不变</li>
</ol>
</blockquote>
</li>
</ul>
<blockquote>
<p><strong>VxLAN如何解决的?</strong><br>VxLAN最重要的能力: VxLAN通过隧道技术，可以实现在跨越三层设备的情况下，这两台server就像在同一个LAN之间通信是一样的(mac地址直接可达)</p>
</blockquote>
<h2 id="2-VxLAN原理"><a href="#2-VxLAN原理" class="headerlink" title="2. VxLAN原理"></a>2. VxLAN原理</h2><h3 id="2-1-VxLAN框架"><a href="#2-1-VxLAN框架" class="headerlink" title="2.1 VxLAN框架"></a>2.1 VxLAN框架</h3><p><img src="/2022/07/27/VxLAN/image-20220520170337.png" alt="image2"><br>1）VTEP（VXLAN tunnelend point，VXLAN隧道端点)：VXLAN的边缘设备，针对VXLAN的处理都在VTEP上进行，例如识别以太网数据帧所属的VXLAN，基于VXLAN对数据帧进行二层转发、封装/解封装报文等。VTEP可以是一台独立的物理设备也可以是虚拟机所在的服务器。</p>
<p>2）VXLAN隧道：两个VTEP之间的点到点的逻辑隧道，VTEP为数据帧封装VXLAN头，UDP头和IP头，通过VXLAN隧道将封装后的报文传递到远端VTEP，远端VTEP设备对其进行解封装。</p>
<p>3）核心设备：IP核心网络中的设备，其核心设备不需要参与VXLAN的处理，仅需根据封装后报文的目的IP地址地报文进行三次转发。</p>
<p>4）VSI（VirtualSwitch Instance，虚拟交换实例）：VTEP上为一个VXLAN提供二层交换服务的虚拟交换实例，可以看做是VTEP设备上一台基于VXLAN进行二层转发的虚拟交换机，它可以具有传统以太网交换机所具有的所有功能，包括源MAC地址的学习、MAC地址老化，洪泛等。VSI与VXLAN一一对应。</p>
<h3 id="2-2-VXLAN报文封装格式"><a href="#2-2-VXLAN报文封装格式" class="headerlink" title="2.2  VXLAN报文封装格式"></a>2.2  VXLAN报文封装格式</h3><p><img src="/2022/07/27/VxLAN/image-20220520161026.png" alt="image3"><br>在原始的二层数据帧外二次封装 添加8字节的VXLAN头，8字节UDP头和2字节的IP头。</p>
<p>UDP头：携带目的端口号为VXLAN固定UDP端口号（缺省值为4789）</p>
<p>VXLAN头主要包含两部分：</p>
<ol>
<li><p> 标志位：“I”位为1，表示VXLAN投中的VXLAN ID有效；为0，表示VXLAN ID无效，其他保留未用，设置为0；</p>
</li>
<li><p> VXLAN ID：用来标识一个VXLAN网络，长度为24比特；</p>
</li>
</ol>
<h2 id="3-VxLAN隧道"><a href="#3-VxLAN隧道" class="headerlink" title="3. VxLAN隧道"></a>3. VxLAN隧道</h2><p>为了将VXLAN报文传递到远端VTEP，需要创建VXLAN隧道，并将VXLAN隧道与VXLAN关联起来。</p>
<p>1、  创建VXLAN隧道</p>
<p>（1）      <strong>手工方式</strong>：手工配置Tunnel接口，并指定隧道的源和目的IP地址分别为本端和远端VTEP的IP地址；</p>
<p>（2）      自动方式：通过ENDP（Enhance Neighbor Discovery Protocol，增强的邻居发现协议）发现远端VTEP，自动在本端和远端VTEP之间建立VXLAN隧道。</p>
<p>2、  关联VXLAN隧道与VXLAN</p>
<p>（1）      手工方式：手工将VXLAN隧道和VXLAN进行关联；</p>
<p>（2）      自动方式：通过扩展IS-IS协议发布VXLAN ID信息。VTEP在所有的VXLAN隧道上通过IS-IS将本地存在的VXLAN ID通告给远端VTEP。</p>
]]></content>
      <categories>
        <category>Networking</category>
      </categories>
  </entry>
  <entry>
    <title>PPPoE</title>
    <url>/2022/09/06/PPPoE/</url>
    <content><![CDATA[<h1 id="1-PPPoE简介"><a href="#1-PPPoE简介" class="headerlink" title="1. PPPoE简介"></a>1. PPPoE简介</h1><p><strong>什么是PPPoE？</strong></p>
<ul>
<li>PPPoE (Point-to-Point over Ethernet) 可以称作以太网上的PPP协议。</li>
<li>PPPoE实现了在Ethernet上提供点到点的连接，建立PPP会话。</li>
<li>PPPoE利用以太网，将多用户连接到远程接入设备上(Bras)，提供访问控制功能，并且能够提供计费功能，因为被广泛应用于接入运营商网络。</li>
</ul>
<p><strong>PPPoE解决了什么问题？</strong></p>
<ul>
<li>Ethernet具有技术成熟，简单易用，成本低等特点，但是Ethernet协议并没有设计用户验证字段，使得其通信双方无法相互验证对方的身份，因而通信是不安全的。</li>
<li>PPP协议是一种点对点协议，只能用户点到点网络，工作与OSI模型中的第二层，数据链路层，主要用于全双工的异步链路上进行点到点的数据传输。所以PPP协议中没有提供地址信息。</li>
<li>PPP协议的一个重要功能便是提供了身份验证功能。</li>
<li>而Ethernet是一个广播类型的多路访问网络，因而PPP协议是无法直接应用在以太网链路上的。<blockquote>
<p>PPPoE技术应运而生。PPPoE结合了PPP协议通信双方身份验证的功能，在PPP报文外侧再封装PPPoE报头，使其能够承载在Ethernet上。从而实现Ethernet上的点对点通信，使得Ethernet中的客户端能够连接到远端的宽带接入设备上。</p>
</blockquote>
</li>
</ul>
<p><strong>PPPoE的能力</strong></p>
<ul>
<li>PPPoE由于集成了PPP协议，在传统Ethernet上提供了Ethernet本身不具备的 身份验证、加密以及压缩等功能。</li>
<li>PPPoE通过唯一的Session ID，在Ethernet这个多路访问的网络上实现了P2P网络的效果。</li>
<li>PPPoE拨号上网作为一种最常见的方式让终端设备能够连接ISP从而实现宽带接入。</li>
</ul>
<p>总而言之，PPPoE技术将Ethernet技术的经济性与PPP协议的可管理控制性结合在一起，为用户提供接入互联网的功能。<br>对于运营商来说： 它能够最大限度地利用电信接入网现有的体系结构，利用现有的拨号网络资源，运营和管理的模式也不需要很大的改变。<br>对于用户来说：使用感与原来的拨号上网没有太大区别，较容易接受。</p>
<h1 id="2-PPPoE报文"><a href="#2-PPPoE报文" class="headerlink" title="2. PPPoE报文"></a>2. PPPoE报文</h1><p>PPPoE报文的格式就是在以太网帧中携带PPP报文，具体报文格式如下：<br><img src="/2022/09/06/PPPoE/image-20220906224755.png" alt="image-1"></p>
<table>
<thead>
<tr>
<th align="left">报文字段</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Ver域</td>
<td align="left">4bits，PPPoE版本号，值为0x1</td>
</tr>
<tr>
<td align="left">Type域</td>
<td align="left">4bits，PPPoE类型，值为0x1</td>
</tr>
<tr>
<td align="left">Code域</td>
<td align="left">8bits，PPPoE报文类型。Code域为0x00，表示会话数据。Code域为0x09，表示PADI报文；Code域为0x07，表示PADO或PADT报文；Code域为0x19，表示PADR报文；Code域为0x65，表示PADS报文</td>
</tr>
<tr>
<td align="left">Session_ID域</td>
<td align="left">16bits，对于一个给定的PPP会话，该值是一个固定值，并且与以太网Source_address和Destination_address一起实际地定义了一个PPP会话</td>
</tr>
<tr>
<td align="left">Length域</td>
<td align="left">16bits，定义PPPoE的Payload域长度。不包括以太网头部和PPPoE头部的长度</td>
</tr>
</tbody></table>
<h1 id="3-PPPoE的组网结构"><a href="#3-PPPoE的组网结构" class="headerlink" title="3. PPPoE的组网结构"></a>3. PPPoE的组网结构</h1><p>PPPoE协议采用Client/Server模式，基本的PPPoE组网中的角色有PPPoE Client (拨号设备，可以是终端，也可以是光猫)，PPPoE Server (Bras设备)，以及RADIUS设备 (AAA服务器)。</p>
<img src="/2022/09/06/PPPoE/image-20220906225608.png" alt="image-2" style="zoom:50%;">

<h1 id="4-PPPoE工作过程"><a href="#4-PPPoE工作过程" class="headerlink" title="4. PPPoE工作过程"></a>4. PPPoE工作过程</h1><p>PPPoE用户上线需要经过两个阶段，<strong>发现阶段</strong>和<strong>PPP会话阶段</strong>。</p>
<ol>
<li>发现阶段主要是选择PPPoE服务器，并确定索要建立的会话标识符Session ID。</li>
<li>PPP会话阶段即执行标准的PPP过程，包括LCP协商、PAP/CHAP认证、NCP协商等阶段。</li>
</ol>
<img src="/2022/09/06/PPPoE/image-20220906225825.png" alt="image-6" style="zoom: 50%;">

<h2 id="4-1-发现阶段"><a href="#4-1-发现阶段" class="headerlink" title="4.1 发现阶段"></a>4.1 发现阶段</h2><img src="/2022/09/06/PPPoE/image-20220906230323.png" alt="image-3" style="zoom:50%;">
发现阶段是指接入设备为用户分配接入的Session ID，用来标识一条用户与接入设备之间的PPPoE虚拟链路。

<ol>
<li>PPPoE Client广播一个PADI(PPPoE Active Discovery Initiation，PPPoE激活发现起始)报文，在此报文中包含用户想要得到的服务类型信息。</li>
<li>以太网内的所有PPPoE Server在收到这个初始化报文后，将其中请求的服务与自己能提供的服务进行比较，其中可以为PPPoE Client提供此服务的PPPoE Server会回应PADO(PPPoE Active Discovery Offer，PPPoE激活发现服务)报文。</li>
<li>PPPoE Client可能会收到多个PPPoE Server回应的PADO报文。PPPoE Client会根据一定的条件从返回PADO报文的PPPoE Server中选定符合条件的PPPoE Server，并向它返回一个会话请求报文PADR（非广播）(PPPoE Active Discovery Request，PPPoE激活发现请求)，在PADR报文中封装所需的服务信息。</li>
<li>被选定的PPPoE Server在收到PADR报文后，PPPoE Server会产生一个唯一的会话标识以标识它和PPPoE Client的这段PPPoE会话。并把这个特定的会话标识包含在会话确认报文PADS（PPPoE Active Discovery Session-confirmation，PPPoE激活发现会话确认）中回应给PPPoE Client，如果没有错误发生就进入到PPP会话阶段，而PPPoE Client在收到会话确认报文后如果没有错误发生也进入到PPP会话阶段。</li>
</ol>
<h2 id="4-2-PPP会话阶段"><a href="#4-2-PPP会话阶段" class="headerlink" title="4.2 PPP会话阶段"></a>4.2 PPP会话阶段</h2><p>PPP会话阶段包括<strong>LCP协商、PAP/CHAP认证、NCP协商</strong>等阶段。</p>
<p><strong>LCP协商</strong><br><img src="/2022/09/06/PPPoE/image-20220906231947.png" alt="image-4" style="zoom:50%;"><br>进入PPP会话阶段之后，首先进行LCP协商，LCP协商过程如下：</p>
<ol>
<li> PPPoE Client与PPPoE Server互相发送LCP Configure-Request报文。</li>
<li>双方收到Configure-Request报文后，根据报文中协商选项支持情况做出适当的回应（请参见下表）。若两端都回应了Configure-ACK，则标志LCP链路建立成功，否则会继续发送Request报文： <ul>
<li>  如果在设定的LCP协商间隔与协商次数内，对端回应了Configure-ACK，则LCP链路建立成功。</li>
<li>  如果在超过了设定的LCP协商次数后，对端尚未回应Configure-ACK，则终止LCP协商。</li>
</ul>
</li>
<li> LCP链路建立成功后，PPPoE Server会周期性地向PPPoE Client发送LCP Echo-Request报文，然后接收PPPoE Client回应的Echo-Reply报文，来探测LCP链路是否正常，以维持LCP连接。</li>
</ol>
<p><strong>PAP/CHAP认证</strong><br>LCP协商完成后，会进入认证阶段，可以通过PAP认证和CHAP认证两种认证方式实现。</p>
<ul>
<li>PAP认证：PAP为两次握手协议，是通过用户名和密码来对用户进行认证，并且是以明文的方式传递用户名和密码。</li>
<li>CHAP认证：CHAP认证为三次握手协议，也是通过用户名和密码来对用户进行认证，但是加密传递用户密码。</li>
</ul>
<p><strong>NCP协商</strong><br><img src="/2022/09/06/PPPoE/image-20220906232153.png" alt="image-2" style="zoom:50%;"><br>NCP有很多种，如IPCP、BCP、IPv6CP，最为常用的是IPCP（Internet Protocol Control Protocol)协议。<br>NCP的主要功能是协商PPP报文的网络层参数，如IP地址，DNS Server IP地址，WINS Server IP地址等。<br>NCP流程与LCP流程类似，用户与接入设备之间互相发送NCP Config-Request报文并且互相回应NCP Config-Ack报文后，标志NCP己协商完，用户上线成功，可以正常访问网络了。 </p>
]]></content>
      <categories>
        <category>Networking</category>
      </categories>
  </entry>
  <entry>
    <title>Pacman</title>
    <url>/2022/09/22/Pacman/</url>
    <content><![CDATA[<h1 id="1-软件管理命令"><a href="#1-软件管理命令" class="headerlink" title="1. 软件管理命令"></a>1. 软件管理命令</h1><h2 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h2><p><code>pacman -Sy</code>: 同步远程仓库中的软件包数据库</p>
<p><code>pacman -Su</code>：升级所有”已安装的”软件包</p>
<p><code>pacman -Syu</code>: 同步远程仓库中的软件包数据库，并升级所有”已安装的”软件包</p>
<h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p><code>pacman -S (软件名)</code>: 安装软件，若有多个软件包，空格分隔</p>
<p><code>pacman -S --needed (软件名)</code>: 安装软件，若存在，不重新安装最新的软件</p>
<p><code>pacman -Sv (软件名)</code>: 输出操作信息后安装</p>
<p><code>pacman -U (软件名.pkg.tar.gz)</code>: 安装本地软件包</p>
<p><code>pacman -U (http://www.xxx.com/xxx.pkg.tar.xz)</code>: 安装一个远程包</p>
<h2 id="删除软件"><a href="#删除软件" class="headerlink" title="删除软件"></a>删除软件</h2><p><code>pacman -R (软件名)</code>: 只卸载软件包不卸载依赖的软件</p>
<p><code>pacman -Rv (软件名)</code>: 卸载软件，并输出卸载信息</p>
<p><code>pacman -Rs (软件名)</code>: 卸载软件，并同时卸载该软件的依赖软件</p>
<p><code>pacman -Rsn (软件名)</code>: 卸载软件，并同时卸载该软件的依赖软件, 以及该软件的全局配置文件</p>
<h2 id="搜索软件"><a href="#搜索软件" class="headerlink" title="搜索软件"></a>搜索软件</h2><blockquote>
<p>Pacman使用-Q参数来查询本地软件包数据库<br>Pacman使用-S参数来查询远程同步的数据库</p>
</blockquote>
<p><code>pacman -S (软件名)</code>: 在仓库搜索软件包的准确名称</p>
<p><code>pacman -Ss (关键字)</code>: 在仓库搜索包含关键字的软件包, -s是开启内置的正则表达式</p>
<p><code>pacman -Sl</code>: 显示软件仓库所有软件的列表</p>
<p><code>pacman -Si (软件名)</code>: 在远程仓库中查看软件包的详细信息</p>
<p><code>pacman -Q (软件名)</code>: 查看软件包是否已安装</p>
<p><code>pacman -Qs (关键字)</code>: 正则表达式搜索已安装的软件包</p>
<p><code>pacman -Qu</code>: 列出可升级的软件包</p>
<p><code>pacman -Qi (软件包)</code>: 查看某个已安装软件包详细信息</p>
<p><code>pacman -Ql (软件名)</code>: 列出软件包所有文件安装路径</p>
<p><code>pacman -Qdt</code>: 列出所有目前不被需要的依赖软件</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h2><p><code>pacman -Sw (软件名)</code>: 只下载软件包，而不安装<br><code>pacman -Qc</code>: 清理当前已下载但未被安装软件包的缓存(所有软件包都在/var/cache/pacman/pkg)</p>
<p><code>pacman -R $(pacman -Qdtq)</code>: 删除所有目前不被需要的依赖软件</p>
<h1 id="2-Pacman相关"><a href="#2-Pacman相关" class="headerlink" title="2. Pacman相关"></a>2. Pacman相关</h1><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>pacman的配置文件: <code>/etc/pacman.conf</code></p>
<p>官方镜像配置文件: <code>/etc/pacman.d/mirrorlist</code></p>
<p>pacman下载的软件包存放路径: <code>/var/chache/pacman/pkg</code></p>
<h2 id="修改镜像源"><a href="#修改镜像源" class="headerlink" title="修改镜像源"></a>修改镜像源</h2><p><code>pacman-mirrors -i -c China -m rank</code></p>
<h2 id="添加仓库"><a href="#添加仓库" class="headerlink" title="添加仓库"></a>添加仓库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/pacman.conf</span><br><span class="line"></span><br><span class="line">[archlinuxcn]</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure>
<p><code>pacman-mirrors -g</code>: 生成镜像列表</p>
<p><code>pacman -S archlinuxcn-keyring</code>: 安装 archlinuxcn-keyring 包以导入 GPG key</p>
<blockquote>
<p>Note: archlinuxcn是整合了国内优秀开发者软件的”AUR”</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
</search>
